'use strict',function(){const b={};b.doc={id:'id',field:['title','content'],store:['title','href']};const a=FlexSearch.create(b);window.geekdocSearchIndex=a,a.add({id:0,href:'/categories/',title:"Categories",content:""}),a.add({id:1,href:'/features/',title:"Features",content:" Simple, flexible, and lightweight. Deploys a deletes Kubernetes resources. Deploy anything, a Namespace, Ingress, CRD, domain apps (e.g Deployment+Service)\u0026hellip; Garbage collection resources. Load states from different sources/providers (fs, git, kubernetes\u0026hellip;). Plans at Kubernetes resource level (not file/manifest level, not app/release level) Gitops ready (split commands, understands git repositories, apply only changes, Diff, Dry run\u0026hellip;). Use full syncs or partial syncs based on resource changes/diffs. Deploy priorities. Multiple filtering options (file paths, resource namespace, types\u0026hellip;). Push mode (triggered from CI), not pull (controller). Use Kubectl under the hood (Kubernetes \u0026gt;=v1.18 and server-side apply). Safe deletion of resources (doesn\u0026rsquo;t use prune method to delete K8s resources). Reports of what applies and deletes (useful to combine with other apps, e.g: wait, checks, notifications\u0026hellip;).  "}),a.add({id:2,href:'/provider/git/',title:"Git provider",content:"This provider understands git and can read states from a git repository, these 2 states are based on 2 git revisions.\nUsing before-commit will make a plan based on the manifests of HEAD (new state) and the commit provided (old state). Normally used when executed from master/main branch.\nInstead of providing the before-commit, by default will get the base parent of the current branch HEAD (new state) against the default branch (old state), normally master/main). This provider is used when you are executing kahoy from a branch in a pull request.\nExample of usage:\nkahoy apply \\  --provider \u0026#34;git\u0026#34; \\  --git-before-commit-sha \u0026#34;b060762ef93bbe2d03e108d1788eb3505df519a3\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; "}),a.add({id:3,href:'/',title:"Kahoy documentation",content:" When Kubectl is too simple for your needs and available deployment solutions too complex.\n Maintain Kubernetes resources in sync easily.\nYou probably noticed a big gap between what can be done with kubectl and more advanced tools like Helm and FluxCD. But.. what about all the cases where we just need a bit more than what kubectl can offer?\nKahoy is a minimal and flexible tool to deploy your Kubernetes raw manifest resources to a cluster.\nIt\u0026rsquo;s based on GitOps principles, and out of the box Kubernetes resources. It does not need apps/releases/services/or any other Custom Resource Definitions to manage deployments.\nKahoy will adapt to your needs and not the other way around, its been designed and developed to be generic and flexible enough for raw manifests without adding unneeded complexity.\n"}),a.add({id:4,href:'/provider/kubernetes/',title:"Kubernetes provider",content:"Given an storage ID and a namespace, at the end of the execution it will store the executed state (applied and deleted resources).\nThe ID is important because you can have different states for each Kahoy execution flows on the same cluster.\n Note: The state is stored with a Secret per existing resource. Be aware of object count quota\n With this state storage, it will load the old manifest state from Kubernetes and new manifest state from an fs path. This means that unlike other modes, using dry-run with Kubernetes provider needs access to a cluster.\nThis provider gives reliable and easy management, but is slower (Needs to get the state from the cluster) and requires space on the cluster to store the state (however the stored resources are compressed).\nExample of usage:\nkahoy apply \\  --provider \u0026#34;kubernetes\u0026#34; \\  --kube-provider-id \u0026#34;ci\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Check kahoy state If you want to check all the resource states, you can do (Check Secret annotations for more information):\nkubectl -n {STORAGE_NAMESPACE} get secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; Move kahoy state In case you want to move kahoy state to another namespaces you can get the resources and apply them in another namespace.\nkubectl -n {STORAGE_OLD_NS} get secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; -o json | \\  jq \u0026#39;.items[].metadata.namespace = \u0026#34;{STORAGE_NEW_NS}\u0026#34;\u0026#39; | \\  kubectl -n {STORAGE_NEW_NS} apply -f- Delete kahoy state In the strange case that you want to reset Kahoy state, you can do it by removing these secrets and apply again all the manifests to create the latest state again:\nkubectl -n {STORAGE_NAMESPACE} delete secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; "}),a.add({id:5,href:'/provider/paths/',title:"Paths provider",content:"Given 2 manifest file system paths, plans what needs to be applied against a cluster, and what needs to be deleted.\nThis one is the most generic one and can be used when you want to manage almost everything, e.g previous Kahoy execution, prepare using bash scripts, kustomize, secrets\u0026hellip;\nExample of usage:\nkahoy apply \\  --provider \u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;./old-manifests\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; "}),a.add({id:6,href:'/provider/',title:"Provider",content:"Kahoy needs two manifest states (old and new) to plan what resources need to exist/gone in the cluster. How these manifests are provided is using the provider\n   Provider Easy Flexible Fast History     Kubernetes ✔ ✔ ✖ ✖   Git ✖ ✖ ✔ ✔   Paths ✖ ✔ ✔ ✖    "}),a.add({id:7,href:'/tags/',title:"Tags",content:""})}()