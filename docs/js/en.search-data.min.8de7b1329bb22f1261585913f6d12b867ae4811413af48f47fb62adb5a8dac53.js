'use strict',function(){const b={};b.doc={id:'id',field:['title','content'],store:['title','href']};const a=FlexSearch.create(b);window.geekdocSearchIndex=a,a.add({id:0,href:'/introduction/getting-started/',title:"Getting started",content:"Prerequisites  A Kubernetes cluster and access to it. Kahoy and Kubectl installed. A folder with Kubernetes manifests.  Install Kahoy Get the latest binary release from Github or refer to the Installing Kahoy section.\nUsing Kahoy We\u0026rsquo;re going to go through a brief example of how a normal interaction deploying manifests with Kahoy would look like.\nWe\u0026rsquo;re given the following scenario:\n Kahoy is configured with the default Kubernetes provider. Which means that it will store Kahoy\u0026rsquo;s execution state on Kubernetes. We\u0026rsquo;ve decided to identify Kahoy\u0026rsquo;s state with the id ci. It will be stored on the default namespace. There is a folder called ./manifests containing kubernetes manifests.  First we want to check what would be applied on the first run so to be safe we\u0026rsquo;re going to use the dry run mode.\nkahoy apply --dry-run --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; We\u0026rsquo;ve checked the dry run output and it looks good. Optionally if you wanted more information about the difference between what you want to apply and what is on the cluster, the diff mode is available.\nkahoy apply --diff --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; The output of the diff also looks good. It\u0026rsquo;s time to really apply the manifest changes.\nkahoy apply --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; You will be prompted with a message to confirm the apply. You can use the argument --auto-approve to omit the interactive mode.  Now lets see how kahoy handles changes and deletions. Change any of the resources/manifests in ./manifests and delete some others.\nTell kahoy that we only want to apply the resources that changed since latest execution. Lets check with dry run and diff.\nkahoy apply --dry-run --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; --include-changes kahoy apply --diff --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; --include-changes And finally apply them on the cluster.\nkahoy apply --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; --include-changes That\u0026rsquo;s it!\nLets summarize what have we seen in this starting guide:\n Sync a group of Kubernetes resources in YAML files we had on the filesystem. Apply a subset of resources that changed since the last execution. Check how Kahoy handles any kind of resource and structure. Handle garbage collection of resource that have been removed. Multiple execution modes.  This wraps up the common and basic usage of Kahoy. If you liked it there are many other options to fit your needs so keep reading!\nClean In case you want to clean kubernetes state (identified by Kahoy ci state id) and all the resources used/applied in this guide, you can use /dev/null as the wanted manifests state.\nkahoy apply --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;/dev/null\u0026#34; This will delete everything applied in this guide.\n "}),a.add({id:1,href:'/introduction/alternatives-and-scope/',title:"Alternatives and scope",content:"Alternatives Kahoy was born because the available tools for deployment were too complex for our usecase, more on this under History of the project section. Kubernetes is a complex system by itself, adding more complexity in the cases where is not needed, is not a good solution.\n Helm: Tries solving other kinds of problems, has templating (v2 tiller), the concept of releases, used to deploy single apps\u0026hellip; However, you can use helm for templating and kahoy to deploy the generated manifests. Kustomize: Similar scope as helm but with a different approach, like Helm, you can use kustomize for the templating and kahoy for deploying raw manifests. Kapp: As Kahoy, tries solving the same problems of complexity that come with Helm, Kustomize\u0026hellip; Very similar to Kahoy but with more complex options/flows, Kapp focuses on application level, Kahoy on Kubernetes resources, if you need something more complex than Kahoy, is likely that Kapp is your app. Flux: Controller-based flow, very powerful but complex. If you want a more pull than push approach, maybe you want this. Direct benefits of Kahoy versus flux are the inmediate feedback you can get on CI as opposed to waiting until flux runs and applies your changes. Kubectl: Official tool to interact with the cluster. Is what kahoy uses under the hood, very powerful tool, lots of options, although to make it work correctly with a group of manifests\u0026hellip; you will most likely need scripting. Kahoy really aims to remove that effort from you. We could say that Kahoy is a small layer on top of Kubectl.  Scope  This tool does not perform any form of templating, the generation, and mutation of the YAMLs are out of the scope (We believe the are powerful tools that can be used together with Kahoy for that matter e.g kustomize+kahoy or helm+kahoy). Manage the lifecycle of Kubernetes resources using raw YAML files and GitOps. Run on CI (dry run, diff, apply) Simplicity and flexibility. Just a bit smarter than Kubectl. Plan what should change declaring current and previous states (read about this in the Concepts section)  If you need complex flows for your Kubernetes resources is likely that Kahoy is not for you.\n"}),a.add({id:2,href:'/introduction/install/',title:"Installing Kahoy",content:"Releases Kahoy is compiled for all common platforms and uploaded to Github releases.\nTo get the latest release, grab it here.\nDocker In case you want to use Docker, you have a ready to be used image on docker hub\ndocker pull slok/kahoy Note: This image has Kahoy and other dependencies like kubectl and git.\nBuild from source You can build binaries from source easily.\ngit clone git@github.com:slok/kahoy.git cd ./kahoy make build "}),a.add({id:3,href:'/topics/',title:"Topics",content:""}),a.add({id:4,href:'/topics/concepts/',title:"Concepts",content:"  Resource Group State Provider Kahoy Plan   Resource When we refer to a Resource we mean any Kubernetes resource.\nKahoy internally identifies resources by type, namespace, and name. Thanks to this the user can arrange any number of kubernetes resources in a single yaml or split them in multiple yamls. Both scenarios will be considered equal and it will not affect any of the operations run by Kahoy. Take a look at the following example:\nHaving these 2 manifests:\ngrafana.yaml:\n---apiVersion:apps/v1kind:Deploymentmetadata:name:grafananamespace:monitoring#...---apiVersion:v1kind:ServiceAccountmetadata:name:grafananamespace:monitoring#...---apiVersion:v1kind:Servicemetadata:name:grafananamespace:monitoring#...ingress.yaml:\napiVersion:networking.k8s.io/v1beta1kind:Ingressmetadata:name:grafananamespace:monitoring#...Kahoy would load 4 resources with these IDs:\n apps/v1/Deployment/monitoring/grafana core/v1/Service/monitoring/grafana core/v1/ServiceAccount/monitoring/grafana networking.k8s.io/v1beta1/Ingress/monitoring/grafana   Note: Because resources are identified by their type, ns, and name, you can safely move them around between files and it will not affect how Kahoy identifies them.\n Group A group is a way of adding options (e.g deployment priority) to the resources in the group. You could have one or many based on what you need.\nKahoy will identify the groups from the directory structure that contains the manifests. See the following example:\nGiven this tree and our manifests root in ./manifests\n./manifests/ ├── alertgram │ ├── alertgram-secret.yaml │ └── alertgram.yaml ├── bilrost │ └── bilrost.yaml ├── root-stuff.yaml └── grafana ├── config.yaml ├── grafana-dashboards │ ├── grafana-dashboards-kubernetes.yaml │ └── grafana-dashboards-provision.yaml ├── grafana.yaml └── ingress.yaml These would be the group IDs:\n alertgram bilrost root (this is the root id). grafana grafana/grafana-dashboards  State Provider Kahoy plans what to apply or delete based on an old and a new state of manifests. These states can come from different sources and thats entirely up to the user needs.\nCheck providers section for more information.\nKahoy Plan Kahoy plan is a command that creates an execution plan for the user to inspect. It\u0026rsquo;s calculated based on the old and new states and prompts the user with all the meaningful information about the incoming changes.\n"}),a.add({id:5,href:'/topics/how-does-it-work/',title:"How does it work",content:"A pipeline is probably the best way to illustrate all the things that are happening inside Kahoy. This pipeline consists of 5 major steps:\n Stage 1: Load kubernetes manifests.  Load old state Resources and Groups. Load new state Resources and Groups. Optional: There are filters available to exclude/include certain types of manifests.   Stage 2: Plan by comparing old and new states.  Get existing resources and produce the section Apply in the Plan. Get missing resources and produce the section Delete in the Plan.   Stage 3: Process Kubernetes resources.  Optional: There are filters available to exclude/include certain resources by properties like namespace, type, labels, etcetera.   Stage 4: Main command execution.  Apply resources. Delete resources Optiional: Perform the operations in batches with configurable priorities.   Stage 5: Post operations.  Store state. Output the resulting changes.    The above pipeline is also a good example to show what Kahoy doesn\u0026rsquo;t do. Please visit the scope of this project if you are missing any other functionality.\n"}),a.add({id:6,href:'/topics/modes/',title:"Execution modes",content:"Dry-run Will plan and list the resources that need to exist and be deleted from the cluster.\nEnable this mode using --dry-run flag.\nThis operation doesn\u0026rsquo;t require to use the Kubernetes cluster unless Kubernetes provider is used.  Diff Will get the diff against the current cluster manifests. Requires to connect to the Kubernetes cluster.\nEnable this mode using --diff flag.\nDefault (no options) Will apply the resources that need to exist, and remove the ones that need to be deleted.\nIf we don\u0026rsquo;t provide mode flags, this is the mode that will be used.\nApply uses Kubectl with server-side apply.  "}),a.add({id:7,href:'/topics/provider/',title:"Provider",content:"Kahoy needs two manifest states (old and new) to plan what resources need to exist/gone in the cluster. How these manifests are provided is using the provider\n   Provider Easy Flexible Fast History     Kubernetes ✔ ✔ ✖ ✖   Git ✖ ✖ ✔ ✔   Paths ✖ ✔ ✔ ✖    "}),a.add({id:8,href:'/topics/provider/kubernetes/',title:"Kubernetes",content:"Given an storage ID and a namespace, at the end of the execution it will store the executed state (applied and deleted resources).\nThe ID is important because you can have different states for each Kahoy execution flows on the same cluster.\n Note: The state is stored with a Secret per existing resource. Be aware of object count quota\n With this state storage, it will load the old manifest state from Kubernetes and new manifest state from an fs path. This means that unlike other modes, using dry-run with Kubernetes provider needs access to a cluster.\nThis provider gives reliable and easy management, but is slower (Needs to get the state from the cluster) and requires space on the cluster to store the state (however the stored resources are compressed).\nExample of usage:\nkahoy apply \\  --provider \u0026#34;kubernetes\u0026#34; \\  --kube-provider-id \u0026#34;ci\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Check kahoy state If you want to check all the resource states, you can do (Check Secret annotations for more information):\nkubectl -n {STORAGE_NAMESPACE} get secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; Move kahoy state In case you want to move kahoy state to another namespaces you can get the resources and apply them in another namespace.\nkubectl -n {STORAGE_OLD_NS} get secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; -o json | \\  jq \u0026#39;.items[].metadata.namespace = \u0026#34;{STORAGE_NEW_NS}\u0026#34;\u0026#39; | \\  kubectl -n {STORAGE_NEW_NS} apply -f- Delete kahoy state In the strange case that you want to reset Kahoy state, you can do it by removing these secrets and apply again all the manifests to create the latest state again:\nkubectl -n {STORAGE_NAMESPACE} delete secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; "}),a.add({id:9,href:'/topics/provider/git/',title:"Git",content:"This provider understands git and can read states from a git repository, these 2 states are based on 2 git revisions.\nUsing before-commit will make a plan based on the manifests of HEAD (new state) and the commit provided (old state). Normally used when executed from master/main branch.\nInstead of providing the before-commit, by default will get the base parent of the current branch HEAD (new state) against the default branch (old state), normally master/main). This provider is used when you are executing kahoy from a branch in a pull request.\nExample of usage:\nkahoy apply \\  --provider \u0026#34;git\u0026#34; \\  --git-before-commit-sha \u0026#34;b060762ef93bbe2d03e108d1788eb3505df519a3\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; "}),a.add({id:10,href:'/topics/provider/paths/',title:"Paths",content:"Given 2 manifest file system paths, plans what needs to be applied against a cluster, and what needs to be deleted.\nThis one is the most generic one and can be used when you want to manage almost everything, e.g previous Kahoy execution, prepare using bash scripts, kustomize, secrets\u0026hellip;\nExample of usage:\nkahoy apply \\  --provider \u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;./old-manifests\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; "}),a.add({id:11,href:'/topics/sync-types/',title:"Sync types",content:"TODO\nPartial TODO\nFull TODO\n"}),a.add({id:12,href:'/topics/batch-priorities/',title:"Batch and priorities",content:"As we have seen in the concepts section, Kahoy has the concept of groups. Kahoy can use these to give special options to all the resources in group.\nPriority If priority is configured for a group, depending on the priority it will be batched and applied differently to the default one.\nThe priority is given with an integer that represents the order of the batches, by default is 1000. This means that a group with a priority of 200, will be batched and applied after a group with priority of 50 and before the default batch 1000.\nNormally should be fine to use the default one (no usage of priorities), however, you may want to deploy some groups first (e.g CRDs, NS\u0026hellip;).\nThe priorities can be configured in Kahoy\u0026rsquo;s config file, lets see an example:\nversion:v1groups:- id:crdpriority:200- id:nspriority:100- id:system/rolespriority:300- id:apps/app1/dependenciespriority:200With this configuration, Kahoy will create 4 batches to apply them in this order:\n 1st batch (100): ns/ resources. 2nd batch (200): crd/ and apps/app1/dependencies resources. 3rd batch (300): system/roles/ resources. 4th batch (1000): Rest of the resources (default priority).  Priorities are not used on resource deletion  Wait Apart from priorities that specify the execution order, you can wait between batches.\nNormally you would wait for some kind of ready condition, however there are lots of different resource types, each resource having lots of different conditions that can be seen as ready. This is complex.\nKahoy took the simplest approach. Instead of implementing tons of ways to wait for a ready condition, its based on eventual consistency concept and a waiting time.\nLets see an example:\ngroups:- id:crdpriority:200wait:duration:5sThis will make kahoy wait 5s after applying the crd batch (200) before continuing applying the next one.\nIf two groups with the same priority have different wait durations, Kahoy will take the highest wait value  "}),a.add({id:13,href:'/topics/filtering/',title:"Filtering resources",content:"TODO\n"}),a.add({id:14,href:'/topics/report/',title:"Report",content:"Kahoy can give a report at the end of the execution with the information of the resources that have been deleted and applied.\nThis is very flexible and powerful because it gives the ability to plug new apps after Kahoy execution e.g:\n Push notifications Wait for resources be available: Example. Push metrics. Execute sanity checks \u0026hellip;  This approach follows unix philosophy of having multiple tools, each one doing one thing well and combining them to solve an specific problem (e.g Kahoy | jq | waiter).\nBy default it doesn\u0026rsquo;t give the report, use --report-path (-r) flag, using - for stdout (-r -), or a path to an output file (e.g -r /tmp/kahoy-report.json.\nThe format is in JSON because this way it can be combined with tools like [jq], example:\n{ \u0026#34;version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;01EHXWW5XNQF3V8WF14Z3GCAZT\u0026#34;, \u0026#34;started_at\u0026#34;: \u0026#34;2020-09-11T06:15:38Z\u0026#34;, \u0026#34;ended_at\u0026#34;: \u0026#34;2020-09-11T06:15:54Z\u0026#34;, \u0026#34;applied_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;apps/v1/Deployment/test-kahoy/grafana\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/grafana\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;apps/v1/Deployment\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;apps/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Deployment\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;grafana\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;core/v1/Namespace/default/test-kahoy\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;ns\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;/v1/Namespace\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Namespace\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;test-kahoy\u0026#34; } ], \u0026#34;deleted_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role/test-kahoy/prometheus\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/prometheus\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Role\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;prometheus\u0026#34; } ] } "}),a.add({id:15,href:'/topics/garbage-collection/',title:"Garbage collection",content:"TODO\n"}),a.add({id:16,href:'/topics/configuration-file/',title:"Configuration file",content:"Most of kahoy options are based on flags (and env vars), however it also has some options that are based in a configuration file. The file options.\nBy default it will look for ./kahoy.yml, yet you can configure using --config-file flag.\nLets see what are the available options based on an example:\n# Version of the configuration format.version:v1# File system configuration.fs:# Exclude regex for file paths (same as `--fs-exclude`, can be used both).exclude:- prometheus/secrets- secret*# Include regex for file paths (same as `--fs-include`, can be used both).include:- apps/# List of groups configuration.groups:# Represented by the group ID- id:crd# Priority of the group (by default is 1000). Applied in asc order.priority:200# Wait options.wait:# The time will wait after being applied (Ts, Tm, Th format).duration:5s- id:nspriority:100wait:duration:10s- id:system/rolespriority:300"}),a.add({id:17,href:'/topics/create-namespace/',title:"Create namespace",content:"TODO\n"}),a.add({id:18,href:'/use-cases/',title:"Use cases",content:"  Dry run on pull requests Diff for CI Pull requests Deploying on master branch (when PR merged) Schedule a full sync Exclude some manifest files (e.g encrypted secrets) Delete all Deploy all Deploy only some manifests Multiple envs batch by priorities Kustomize and Kahoy   Dry run on pull requests When someone pushes a branch different from master, would be nice to execute Dry run on the changes (partial sync) of that branch.\nHaving our manifest in a git repository in ./manifests and being our default branch master, we do this from a different branch.\nkahoy apply \\  --dry-run \\  --include-changes \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Diff for CI Pull requests Same as above but with --diff instead of --dry-run\nDeploying on master branch (when PR merged) Kahoy needs to compare our HEAD against the previous applied state, that\u0026rsquo;s why we need the before-commit. In this example, we use --git-before-commit-sha flag. Normally this variable can be obtained in the executing CI:\nGithub actions uses Github context, example:\nenv:GIT_BEFORE_COMMIT_SHA:${{ github.event.before }}So\u0026hellip; in Kahoy:\nkahoy apply \\  --include-changes \\  --git-before-commit-sha \u0026#34;${GIT_BEFORE_COMMIT_SHA}\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Note: For Gitlab CI, this uses env vars (in CI_COMMIT_BEFORE_SHA).\nSchedule a full sync Check this Github actions example for more info.\nExclude some manifest files (e.g encrypted secrets) If you have some files that you don\u0026rsquo;t want to be managed by kahoy, you can ignore them at file system level using --fs-exclude. Can be repeated.\nE.g: exclude any file with the name secret on it.\nkahoy apply \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-exclude \u0026#34;secret\u0026#34; Delete all Instead of using git, use the fs by using the paths provider. Use the new state as dev/null.\nkahoy apply \\  --provider=\u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-new-manifests-path \u0026#34;/dev/null\u0026#34; Deploy all Instead of using git, use the fs by using the paths provider. Use the old state as dev/null.\nkahoy apply \\  --provider=\u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;/dev/null\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Deploy only some manifests You can use the file filtering option --fs-include, works with any provider (git, paths\u0026hellip;)\nkahoy apply \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-include \u0026#34;./manifests/prometheus\u0026#34; \\  --fs-include \u0026#34;./manifests/grafana\u0026#34; Multiple envs If you have multiple envs on the same repository, you can have them in different manifests root.\nkahoy apply \\  --kube-context \u0026#34;env1\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests/env1\u0026#34; kahoy apply \\  --kube-context \u0026#34;env2\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests/env2\u0026#34; batch by priorities Kahoy knows how to manage priorities between groups. By default it will batch all the manifests with a default priority (1000), but maybe you want to deploy some groups first (e.g CRDs or the NS).\nGiven this kahoy.yml on your repo root (or any other path and use --config-file), with the group options:\nversion:v1groups:- id:crdpriority:200- id:nspriority:100- id:system/rolespriority:300it will make Kahoy apply first the ns group, then crd group, then system/roles group, and finally the rest.\nKustomize and Kahoy Check this Kustomize example.\n"}),a.add({id:19,href:'/tutorials/',title:"Tutorials",content:"TODO\n"}),a.add({id:20,href:'/community/',title:"Community",content:"Learn here about the development process and how you can contribute.\n"}),a.add({id:21,href:'/community/contributing/',title:"Contributing",content:"The contributing information is in Github, check CONTRIBUTING.md file\n"}),a.add({id:22,href:'/community/history/',title:"History of the project",content:"TODO\n"}),a.add({id:23,href:'/faq/',title:"F.A.Q",content:"  Can I deploy anything? What does focused on resource level mean? What about CRDs? Why old and new states? Why file changes don\u0026rsquo;t affect resources? Can I have multiple manifests envs on the same repository? Partial and full syncs? How is Garbage collection handled? Why git? When to use paths provider? When to use Kubernetes provider? Env vars as options Kustomize or helm manifests Encrypted secrets? Non resource YAMLs Ignore a resource Why so many filtering options? I have namespace not found error on regular apply or diff Why don\u0026rsquo;t use kubectl prune to delete resources? Github actions integration Configuration file Report   Can I deploy anything? Yes, Kahoy is focused on resource level, you will not need any app scope, labels to group them, or anything similar. You can deploy from 500 apps to 1 namespace.\nWhat does focused on resource level mean? When we talk about resource level, it means that Kahoy identifies what to deploy/delete based on the Kubernetes resource ID (type + ns + name).\nOther solutions add concepts like release (Helm) or app (Kapp), these use/add special fields like labels to identify them.\nNot depending on these fields gives Kahoy, flexibility to deploy anything, and not depending on anything external to what the user defines in its manifests.\nHowever, if you want to group them by app/release, you can always generate these manifests using helm or kustomize templating and let them add those grouping labels, Kahoy will handle correctly the manifests/resources as they are.\nWhat about CRDs? CRDs are also Kubernetes resources, Kahoy knows how to handle them.\nWhy old and new states? In order to be able to track resource changes (e.g track deletion of resource). We need a way to detect what resources have been created/changed/gone.\nAs we explained in another question, Kahoy doesn\u0026rsquo;t depend on special concepts like release/app/special labels\u0026hellip; so to be able to track this we need to use something else, we use a previous (old) state and a current (new) state of the manifests, we compare them and then we can track what has changed.\nNormally the manifests are already in Git, Git has history, so getting this information from git is enough and integrates perfectly with code review flows and Kahoy.\nWhy file changes don\u0026rsquo;t affect resources? Because Kahoy loads resources and then plans what has changed, e.g:\nYou have a file called app.yaml and has these resources with the IDs:\n A service called app1 on the ns apps: v1/Service/apps/app1 A Deployment called app1 on the ns apps: apps/v1/Deployment/apps/app1 An ingress called app1 on the ns apps: networking.k8s.io/v1beta1/Ingress/apps/app1  Now you split the file in\n deployment.yaml: apps/v1/Deployment/apps/app1 svc.yaml: v1/Service/apps/app1 ingress.yaml: networking.k8s.io/v1beta1/Ingress/apps/app1  For Kahoy internally, are the same.\nCan I have multiple manifests envs on the same repository? Yes, Kahoy takes a root manifest-path, as long as that root is the one for the environment, it should be ok.\nYou can invoke Kahoy N times, one per environment.\nPartial and full syncs? Partial syncs filter the resources that will apply based on the changes from one state to another (checks diffs between kubernetes resources in both states). Use --include-changes for partial syncs.\nFull syncs apply all the resources.\nCheck this Github actions example for more info.\nHow is Garbage collection handled? Kahoy takes manifests in 2 states, an old state, and a new state. It compares both and checks what\u0026rsquo;s missing in the new one comparing the old one. Those are the resources that will be deleted (garbage collected).\nThe deletion is made in a resource manner using Kubectl delete, this is safe because Kahoy selects what wants to delete so, it already knows what is going to be delete on the server.\nOther methods like prune are not safe, and that\u0026rsquo;s why Kahoy doesn\u0026rsquo;t use them.\nWhy git? Git maintains history of the manifests, it tracks the changes, can be reverted, is known by almost everyone\u0026hellip; this makes the manifests lifecycle to be reliable.\nThis gives us the opportunity to track changes on our resources, applying a reliable flow based on code reviews (Pull requests).\nThat\u0026rsquo;s why Kahoy understands git, knows how to get two revisions, and compares the manifests that changed in those revisions, plan them and apply.\nWhen to use paths provider? Kahoy understands git and most of the time you will not need it if you are using a repository. However, if you want to make everything yourself, using paths provider gives you full control. e.g:\n Prepare two manifest paths.  new manifests is the main repository old manifests is a copy of new (cp -r) and checkout to a previous revision.   Use --provider=paths to pass those manifest paths (--fs-old-manifests-path, --fs-new-manifests-path) to the two repo paths in different states. If you want to only apply on changes, use --include-changes.  Check an example script that prepares two manifests paths with the different revisions.\nWhen to use Kubernetes provider? When you want Kahoy manage the latest state for you instead of you managing the latest state (e.g: Using Git history).\nThis will make an easy and reliable way of managing the state.\nEnv vars as options You can use environment vars as options using KAHOY_XXXX_XXXX, cli args have priority. e.g:\n --debug: KAHOY_DEBUG --kube-context: KAHOY_KUBE_CONTEXT --provider: KAHOY_PROVIDER --fs-include: KAHOY_FS_INCLUDE \u0026hellip;  Kustomize or helm manifests You can maintain the generated manifests in git as a previous step to make the PRs, this would make that the final autogenerated manifests are committed and ready in the git history, ready to be used by Kahoy at any time (including CI) and cleaner on the PRs when multiple manifests change.\nCheck this Kustomize example.\nEncrypted secrets? Encrypted secrets can\u0026rsquo;t be understood by Kahoy, there are different solutions:\n Ignore encrypted files and apply them separately.  Invoke Kahoy ignoring them using --fs-exclude. Decrypt the secrets. Apply them using Kahoy with --provider=paths and --fs-include option.   Move to a different solution where git repository doesn\u0026rsquo;t have encrypted secrets (webhooks, controllers\u0026hellip;).  Non resource YAMLs Kahoy will try loading all yamls as resources, if it fails, Kahoy will fail, this can be a problem when you have yamls that are not Kubernetes resources.\nUse --fs-exclude, it works with paths and git providers.\nIgnore a resource You can ignore resources at different levels and using multiple filters.\nAt file level you have --fs-include and --fs-exclude, these exclude or include based on filesystem path regexes.\nAt Kubernetes resource level you have others:\n --kube-exclude-type: Exclude based on Kubernetes type regex (e.g: apps/*/Deployment, v1/Pod\u0026hellip;). --kube-include-label: Kubernetes style selector that will select only the resources that match the label selector (e.g: app=myapp,component!=database,env) --kube-include-annotation: Kubernetes style selector that will select only the resources that match the annotation selector (e.g: app=myapp,component!=database,!non-wanted-key)  Why so many filtering options? There isn\u0026rsquo;t a correct manifest structure, grouping, naming\u0026hellip; These can be, spliting a repo per env, a monorepo for everything, a repo for each app\u0026hellip;\nKahoy tries adapting to most use cases, so, having multiple ways of including/excluding resources/manifests is a good way of adapting to the different users.\nAll these filtering options give users a way of solving lots of use cases, for example splitting CI deployments in many ways, e.g:\n Deploy single env on a monorepo identified by paths (--fs-include envs/prod). Deploy single env on a monorepo on the same path, identified by labels, e.g Kustomize generated files (--kube-include-label env=prod). Split CI steps by env. Split CI steps by nature (Kahoy with everything except secrets -\u0026gt; decrypt secrets -\u0026gt; Kahoy all secrets). Updating a single service (--fs-include apps/app1). Exclude encrypted files (--fs-exclude secret) Exclude an specific app (--fs-exclude apps/app1) Ignore CRDs that have an annotation, becase controller change the information (--kube-include-annotation ...) Integrate Kahoy gradually including manifests (--fs-include monitoring/grafana --fs-include monitoring/prometheus) \u0026hellip;  I have namespace not found error on regular apply or diff When we apply a namespaced resource on a namespace that does not exists, the action will fail with an error like:\nError from server (NotFound): namespaces \u0026#34;some-namespace\u0026#34; not found This happens when you don\u0026rsquo;t apply/create the Namespaces before the namespaced Kubernetes resources. Or when you do a diff kahoy --diff. Kahoy uses server-side diff, so it will try a fake/dry-run apply to get the diff and because there is no namespace, it will fail.\nThis is a tricky known problem, to solve this at this moment is only one option, and is to create the namespace before the server-side apply.\nBy default Kahoy will not create the missing namespaces of applied resources, but with --create-namespace, it will. This will work with regular mode kahoy apply and also diff mode kahoy apply --diff.\nBe aware using it with --diff would create a namespace, this means that the diff would have a write operation on the cluster, the ns creation.\nIs a good practice that if you use --create-namespace, you add to your resources the Namespace manifest, this way in the case you delete anytime the resources along with the namespace, the created namespace will be garbage collected by Kahoy.\nWhy don\u0026rsquo;t use kubectl prune to delete resources? TL;DR: Is unpredictable, then risky.\n Official documentation discourages --prune. Official documentation encourages delete -f. You never know what will be deleted exactly beforehand. Can delete resources that we didn\u0026rsquo;t even know they exists (because the selector matches). Can have a big blast radius when an error is made in the prune execution. Some controllers/operators create resources and set the labels with the ones from the original resource, this would make prune delete the controller object on each apply with prune.  Github actions integration Check this Github actions example for more info.\nConfiguration file Kahoy accepts a configuration file (by default ./kahoy.yml) to set options, at this moment these are the options:\n# Version of the configuration format.version:v1# File system configuration.fs:# Exclude regex for file paths (same as `--fs-exclude`, can be used both).exclude:- prometheus/secrets- secret*# Include regex for file paths (same as `--fs-include`, can be used both).include:- apps/# List of groups configuration.groups:# Represented by the group ID- id:crd# Priority of the group (by default is 1000). Applied in asc order.priority:200# Wait options.wait:# The time will wait after being applied (Ts, Tm, Th format).duration:5s- id:nspriority:100wait:duration:10s- id:system/rolespriority:300Report Kahoy can give a report at the end of the execution with the information of the resources that have been deleted and applied.\nThis is very flexible and powerful because it gives the ability to plug new apps after Kahoy execution e.g:\n Push notifications Wait for resources be available: Example. Push metrics. Execute sanity checks \u0026hellip;  This approach follows unix philosophy of having N tools, each one doing one thing (e.g Kahoy | jq | waiter).\nBy default it doesn\u0026rsquo;t give the report, use --report-path (-r) flag, using - for stdout (-r -), or a path to an output file (e.g -r /tmp/kahoy-report.json.\nThe format is in JSON because this way it can be combined with tools like jq, example:\n{ \u0026#34;version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;01EHXWW5XNQF3V8WF14Z3GCAZT\u0026#34;, \u0026#34;started_at\u0026#34;: \u0026#34;2020-09-11T06:15:38Z\u0026#34;, \u0026#34;ended_at\u0026#34;: \u0026#34;2020-09-11T06:15:54Z\u0026#34;, \u0026#34;applied_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;apps/v1/Deployment/test-kahoy/grafana\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/grafana\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;apps/v1/Deployment\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;apps/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Deployment\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;grafana\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;core/v1/Namespace/default/test-kahoy\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;ns\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;/v1/Namespace\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Namespace\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;test-kahoy\u0026#34; } ], \u0026#34;deleted_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role/test-kahoy/prometheus\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/prometheus\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Role\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;prometheus\u0026#34; } ] } "}),a.add({id:24,href:'/glossary/',title:"Glossary",content:"Here are the explanations of some words and phrases used along the documentation.\n Resource Group Provider State Report Kubernetes provider id (storage id) Mode Multipurpose deploy tool Focused on Kubernetes resource Focused on app (or release, service\u0026hellip;) Safe deletion Ready for gitops   Resource Sometimes also called Object.\nA Kubernetes object or resource uniquely identified by Kahoy using the type, group, namespace and name. E.g:\n apps/v1/Deployment/monitoring/grafana core/v1/Service/monitoring/grafana core/v1/ServiceAccount/monitoring/grafana networking.k8s.io/v1beta1/Ingress/monitoring/grafana  Group A group of resources under the same path on the file system.\nProvider The mechanism used to obtain the groups and resources. E.g:\n Git repository using the file system. Kubernetes secrets using the apiserver. A file system path.  State A Kahoy executed snapshot of the resource\u0026rsquo;s data (yaml specs). A provider is used to obtain it. E.g:\n Git hash. Kubernetes secrets with some specific label. An file system path.  Report The output kahoy creates with the resources applied and deleted at the end of an execution.\nKubernetes provider id (storage id) The id used to identify Kahoy state on Kubernetes, giving the ability to execute multiple kahoy independent executions by using different ids on the same cluster and namespace.\nMode The way Kahoy is executed. E.g:\n Dry run. Diff. Default (regular).  Multipurpose deploy tool Means that Kahoy can deploy Kubernetes resources in multiple scenarios and use cases. E.g:\n Independent app/release (Helm style). As a full repository (Flux style). Multiple envs (single repository, env per path). Raw or simple (Kubectl style) \u0026hellip;  Focused on Kubernetes resource Means that Kahoy focuses on the Kubernetes resource to identify and work with each of them (check if resource changed from previous state, filtering\u0026hellip;).\nSo, this means that it doesn\u0026rsquo;t need extra information or mutate the resource itself to track it.\nNormally this implies that you are free to organize the deployment the way you want:\n Multiple apps/releases at the same time. Single app/release. Bunch of random resources (e.g register the CRDs).  Focused on app (or release, service\u0026hellip;) Means that the deployment (tool) identifies what deploys using the concept or the domain of a release/app/service.\nNormally this implies creating a namespace for the resources, adding extra labels to track it\u0026hellip;, and can\u0026rsquo;t be used with multiple resources of different apps at the same time.\nAn example could be Helm or Kapp.\nSafe deletion Kahoy uses per resource identification and tracks each resource independently. This implies that it deletes explicitly the required resources, this method avoids side effects unlike prune that can have side effects and is dangerous to use it.\nReady for gitops Means that Kahoy has been designed with CI, Git and automation in mind, so, is ready to be used in systems like Github actions or Gitlab CI easily.\nMore information about Gitops concept: here\n"}),a.add({id:25,href:'/categories/',title:"Categories",content:""}),a.add({id:26,href:'/tutorials/generic-apps-deployments/',title:"Generic app based deployments",content:"TODO\n"}),a.add({id:27,href:'/tutorials/gitops-production-ready-flow/',title:"Gitops production ready flow",content:"TODO\n"}),a.add({id:28,href:'/introduction/',title:"Introduction",content:"Kahoy is a minimal and flexible tool to deploy your Kubernetes raw manifest resources to a cluster.\nIt\u0026rsquo;s based on GitOps principles, and out of the box Kubernetes resources. It does not need apps/releases/services/or any other Custom Resource Definitions to manage deployments.\nKahoy will adapt to your needs and not the other way around, its been designed and developed to be generic and flexible enough for raw manifests without adding unneeded complexity.\nFeatures  Simple, flexible, and lightweight. Deploys a deletes Kubernetes resources. Deploy anything, a Namespace, Ingress, CRD, domain apps (e.g Deployment+Service)\u0026hellip; Garbage collection resources. Load states from different sources/providers (fs, git, kubernetes\u0026hellip;). Plans at Kubernetes resource level (not file/manifest level, not app/release level) Gitops ready (split commands, understands git repositories, apply only changes, Diff, Dry run\u0026hellip;). Use full syncs or partial syncs based on resource changes/diffs. Deploy priorities. Multiple filtering options (file paths, resource namespace, types\u0026hellip;). Push mode (triggered from CI), not pull (controller). Use Kubectl under the hood (Kubernetes \u0026gt;=v1.18 and server-side apply). Safe deletion of resources (doesn\u0026rsquo;t use prune method to delete K8s resources). Reports of what applies and deletes (useful to combine with other apps, e.g: wait, checks, notifications\u0026hellip;).  "}),a.add({id:29,href:'/',title:"Kahoy documentation",content:" When Kubectl is too simple for your needs and available deployment solutions too complex.\n Maintain Kubernetes resources in sync easily.\nYou probably noticed a big gap between what can be done with kubectl and more advanced tools like Helm and FluxCD. But.. what about all the cases where we just need a bit more than what kubectl can offer?\nKahoy is a minimal and flexible tool to deploy your Kubernetes raw manifest resources to a cluster.\nIt\u0026rsquo;s based on GitOps principles, and out of the box Kubernetes resources. It does not need apps/releases/services/or any other Custom Resource Definitions to manage deployments.\nKahoy will adapt to your needs and not the other way around, its been designed and developed to be generic and flexible enough for raw manifests without adding unneeded complexity.\n"}),a.add({id:30,href:'/tutorials/multicluster-deployments/',title:"Multiple env deployments",content:"TODO\n"}),a.add({id:31,href:'/tutorials/scaling-20k-apps/',title:"Scaling Kahoy to 20k apps",content:"TODO\n"}),a.add({id:32,href:'/tags/',title:"Tags",content:""}),a.add({id:33,href:'/tutorials/using-git-provider/',title:"Using Git provider",content:"TODO\n"}),a.add({id:34,href:'/tutorials/waiting-deployments-finish/',title:"Waiting deployment to be ready",content:"TODO\n"})}()