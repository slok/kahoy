'use strict',function(){const b={};b.doc={id:'id',field:['title','content'],store:['title','href']};const a=FlexSearch.create(b);window.geekdocSearchIndex=a,a.add({id:0,href:'/tutorials/production-ready/',title:"Production ready tutorial",content:"This is an example of how you can use multiple tools in combination with Kahoy to obtain a production ready deployment workflow.\nCheck kahoy-helm-example\n"}),a.add({id:1,href:'/introduction/getting-started/',title:"Getting started",content:"Prerequisites  A Kubernetes cluster and access to it. Kahoy and Kubectl installed. A folder with Kubernetes manifests.  Install Kahoy Get the latest binary release from Github or refer to the Installing Kahoy section.\nUsing Kahoy We\u0026rsquo;re going to go through a brief example of how a normal interaction deploying manifests with Kahoy would look like.\nWe\u0026rsquo;re given the following scenario:\n Kahoy is configured with the default Kubernetes provider. Which means that it will store Kahoy\u0026rsquo;s execution state on Kubernetes. We\u0026rsquo;ve decided to identify Kahoy\u0026rsquo;s state with the id ci. It will be stored on the default namespace. There is a folder called ./manifests containing kubernetes manifests.  First we want to check what would be applied on the first run so to be safe we\u0026rsquo;re going to use the dry run mode.\nkahoy apply --dry-run --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; We\u0026rsquo;ve checked the dry run output and it looks good. Optionally if you wanted more information about the difference between what you want to apply and what is on the cluster, the diff mode is available.\nkahoy apply --diff --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; The output of the diff also looks good. It\u0026rsquo;s time to really apply the manifest changes.\nkahoy apply --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; You will be prompted with a message to confirm the apply. You can use the argument --auto-approve to omit the interactive mode.  Now lets see how kahoy handles changes and deletions. Change any of the resources/manifests in ./manifests and delete some others.\nTell kahoy that we only want to apply the resources that changed since latest execution. Lets check with dry run and diff.\nkahoy apply --dry-run --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; --include-changes kahoy apply --diff --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; --include-changes And finally apply them on the cluster.\nkahoy apply --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;./manifests\u0026#34; --include-changes That\u0026rsquo;s it!\nLets summarize what have we seen in this starting guide:\n Sync a group of Kubernetes resources in YAML files we had on the filesystem. Apply a subset of resources that changed since the last execution. Check how Kahoy handles any kind of resource and structure. Handle garbage collection of resource that have been removed. Multiple execution modes.  This wraps up the common and basic usage of Kahoy. If you liked it there are many other options to fit your needs so keep reading!\nClean In case you want to clean kubernetes state (identified by Kahoy ci state id) and all the resources used/applied in this guide, you can use /dev/null as the wanted manifests state.\nkahoy apply --kube-provider-id \u0026#34;ci\u0026#34; -n \u0026#34;/dev/null\u0026#34; This will delete everything applied in this guide.\n "}),a.add({id:2,href:'/introduction/scope-and-alternatives/',title:"Scope and alternatives",content:"It\u0026rsquo;s very important to identify whether Kahoy is the right tool for you. This documentation entry attempts to clarify what is the current scope of the tool and the comparison with other deployment alternative tools out there.\nScope Kahoy was born because the available tools for deployment required a good amount of knowledge and time just to get started with and felt too complex for our usecases. More on this under History of the project section. We really wanted that plug-and-play tool that felt familiar to what we already knew.\n This tool does not perform any form of templating. The generation, and mutation of the YAMLs are out of the scope. We believe the are powerful tools that can be used together with Kahoy for that matter e.g kustomize+kahoy or helm+kahoy. Manage the lifecycle of Kubernetes resources using raw YAML files and GitOps. Run on CI (dry run, diff, apply) for instant user feedback. Simple and flexible. Just a bit smarter than Kubectl. Ability to plan what should change declaring current and previous states (read about this in the Concepts section)  If you really want to get your applications up and running in a fairly simple and reliable way Kahoy is probably the right tool for the job. However if your desired flow consists in a more ellaborated process, and you need to bring in concepts like releases or bundles, we recommend you to take a look at the alternatives section.\nAlternatives  Helm: You are forced to embrace its own ecosystem, in exchange it has templating (v2 tiller), the concept of releases, can be used to deploy single apps\u0026hellip; It\u0026rsquo;s important to note that if you like the templating capabilities of Helm but wish it was easier to deploy them don\u0026rsquo;t forget you can combine both helm and kahoy to deploy generated manifests. Kustomize: Similar scope than helm but with a different approach. Also note that like with Helm, you can use kustomize for templating and kahoy for deployment. Kapp: Like Kahoy, tries to ease up the same complexity issues that come with Helm and Kustomize. In a sense its very similar to Kahoy but it introduces the concept of an Application and works on a higher level. In exchange it comes with more refined options and flows. If you need something more complex than Kahoy, is likely that Kapp is where you should look at. Flux: Controller-based flow. Asynchronous solution, pull based by definition. It\u0026rsquo;s very powerful but lacks the desired feedback you\u0026rsquo;d like when releasing your applications. Kubectl: Official tool to interact with the cluster. Is what kahoy uses under the hood, very powerful tool with many different options. Unfortunately it falls behind when handling multiple manifests and dependencies between them. It also requires a fairly good amount of scripting to get things working. Kahoy really aims to remove that effort from you. We could say that Kahoy is a small layer on top of Kubectl.  "}),a.add({id:3,href:'/introduction/install/',title:"Installing Kahoy",content:"Releases Kahoy is compiled for all common platforms and uploaded to Github releases.\nTo get the latest release, grab it here.\nDocker In case you want to use Docker, you have a ready to be used image on docker hub\ndocker pull slok/kahoy Note: This image has Kahoy and other dependencies like kubectl and git.\nBuild from source You can build binaries from source easily.\ngit clone git@github.com:slok/kahoy.git cd ./kahoy make build "}),a.add({id:4,href:'/topics/',title:"Topics",content:""}),a.add({id:5,href:'/topics/concepts/',title:"Concepts",content:"  Resource Group State Provider Kahoy Plan   Resource When we refer to a Resource we mean any Kubernetes resource.\nKahoy internally identifies resources by type, namespace, and name. Thanks to this the user can arrange any number of kubernetes resources in a single yaml or split them in multiple yamls. Both scenarios will be considered equal and it will not affect any of the operations run by Kahoy. Take a look at the following example:\nHaving these 2 manifests:\ngrafana.yaml:\n---apiVersion:apps/v1kind:Deploymentmetadata:name:grafananamespace:monitoring#...---apiVersion:v1kind:ServiceAccountmetadata:name:grafananamespace:monitoring#...---apiVersion:v1kind:Servicemetadata:name:grafananamespace:monitoring#...ingress.yaml:\napiVersion:networking.k8s.io/v1beta1kind:Ingressmetadata:name:grafananamespace:monitoring#...Kahoy would load 4 resources with these IDs:\n apps/v1/Deployment/monitoring/grafana core/v1/Service/monitoring/grafana core/v1/ServiceAccount/monitoring/grafana networking.k8s.io/v1beta1/Ingress/monitoring/grafana   Note: Because resources are identified by their type, ns, and name, you can safely move them around between files and it will not affect how Kahoy identifies them.\n Group A group is a way of adding options (e.g deployment priority) to the resources in the group. You could have one or many based on what you need.\nKahoy will identify the groups from the directory structure that contains the manifests. See the following example:\nGiven this tree and our manifests root in ./manifests\n./manifests/ ├── alertgram │ ├── alertgram-secret.yaml │ └── alertgram.yaml ├── bilrost │ └── bilrost.yaml ├── root-stuff.yaml └── grafana ├── config.yaml ├── grafana-dashboards │ ├── grafana-dashboards-kubernetes.yaml │ └── grafana-dashboards-provision.yaml ├── grafana.yaml └── ingress.yaml These would be the group IDs:\n alertgram bilrost root (this is the root id). grafana grafana/grafana-dashboards  State Provider Kahoy plans what to apply or delete based on an old and a new state of manifests. These states can come from different sources and thats entirely up to the user needs.\nCheck providers section for more information.\nKahoy Plan Kahoy plan creates an execution plan for the user to inspect. It\u0026rsquo;s calculated based on the old and new states and prompts the user with all the meaningful information about the upcoming changes.\n"}),a.add({id:6,href:'/topics/how-does-it-work/',title:"How does it work",content:"A pipeline is probably the best way to illustrate all the things that are happening inside Kahoy. This pipeline consists of 5 major steps:\n Stage 1: Load kubernetes manifests.  Load old state Resources and Groups. Load new state Resources and Groups. Optional: There are filters available to exclude/include certain types of manifests.   Stage 2: Plan by comparing old and new states.  Get existing resources and produce the section Apply in the Plan. Get missing resources and produce the section Delete in the Plan.   Stage 3: Process Kubernetes resources.  Optional: There are filters available to exclude/include certain resources by properties like namespace, type, labels, etcetera.   Stage 4: Main command execution.  Apply resources. Delete resources Optiional: Perform the operations in batches with configurable priorities.   Stage 5: Post operations.  Store state. Output the resulting changes.    The above pipeline is also a good example to show what Kahoy doesn\u0026rsquo;t do. Please visit the scope of this project if you are missing any other functionality.\n"}),a.add({id:7,href:'/topics/modes/',title:"Execution modes",content:"Dry-run Will prompt the user with an execution plan that lists the resources that would be applied and/or deleted from the cluster in the event of running kahoy in the default mode.\nEnable this mode using --dry-run flag.\nDry run execution mode is a read-only operation.  Diff Will prompt the diff between current resource manifests and existing cluster resources. This mode requires connectivity to the Kubernetes cluster.\nEnable this mode using --diff flag.\nDiff execution mode is a read-only operation.  Default Also known as the apply mode. This operation will modify the state of the cluster applying user desired changes.\nUnless application flags provided, this is the default execution mode.\nUnder the hood the apply mode relies on Kubectl with server-side apply.  "}),a.add({id:8,href:'/topics/provider/',title:"Provider",content:"Kahoy needs two manifest states (old and new) to plan what resources have changed and which delete/apply actions need to be handled.\nHow these manifest states are configured is determined by the provider parameters.\n   Provider Plug and Play Flexible Fast History     Kubernetes (default) ✔ ✔ ✖ ✖   Git ✖ ✖ ✔ ✔   Paths ✖ ✔ ✔ ✖     Plug and Play: Refers to how straightforward is to use Kahoy with this provider. For example using Kahoy with the kubernetes provider works out of the box. However using the git or paths providers would require a few configuration steps from the user. Flexible: Means that the resource can be mutated/processed before applying them, for example decrypting a Secret manifest file. Fast: In terms of how fast kahoy can calculate the changes between the states. For example using the paths provider means old and new manifests can be read from the filesystem so Kahoy will read through them as fast as the hardware can be. Using the kubernetes provider however means you need to fetch the state from the cluster which involves higher latency calls. History: Means that you can apply/delete an specific point in time.  "}),a.add({id:9,href:'/topics/provider/kubernetes/',title:"Kubernetes",content:"Given an storage ID and a namespace, at the end of the execution it will store the executed state (applied and deleted resources).\nThe ID is important because you can have different states for each Kahoy execution flows on the same cluster.\nThe ID has the same requirements as a Kubernetes label value. More info here.  The state is stored with a Secret per existing resource. Be aware of object count quota.  With this state storage, it will load the old manifest state from Kubernetes and new manifest state from an fs path.\nYou can use stdin as the new manifests path with - (-n-/--fs-new-manifests-path -).  This provider gives reliable and easy management, but is slower (Needs to get the state from the cluster) and requires space on the cluster to store the state (however the stored resources are compressed).\nExample of usage:\nkahoy apply \\  --provider \u0026#34;kubernetes\u0026#34; \\  --kube-provider-id \u0026#34;ci\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Check kahoy state If you want to check all the resource states, you can do (Check Secret annotations for more information):\nkubectl -n {STORAGE_NAMESPACE} get secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; Move kahoy state In case you want to move kahoy state to another namespaces you can get the resources and apply them in another namespace.\nkubectl -n {STORAGE_OLD_NS} get secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; -o json | \\  jq \u0026#39;.items[].metadata.namespace = \u0026#34;{STORAGE_NEW_NS}\u0026#34;\u0026#39; | \\  kubectl -n {STORAGE_NEW_NS} apply -f- Delete kahoy state In the strange case that you want to reset Kahoy state, you can do it by removing these secrets and apply again all the manifests to create the latest state again:\nkubectl -n {STORAGE_NAMESPACE} delete secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; "}),a.add({id:10,href:'/topics/provider/git/',title:"Git",content:"This provider understands git and can read states from a git repository, these 2 states are based on 2 git revisions.\nUsing before-commit will make a plan based on the manifests of HEAD (new state) and the commit provided (old state). Normally used when executed from master/main branch.\nInstead of providing the before-commit, by default will get the base parent of the current branch HEAD (new state) against the default branch (old state), normally master/main). This provider is used when you are executing kahoy from a branch in a pull request.\nExample of usage:\nkahoy apply \\  --provider \u0026#34;git\u0026#34; \\  --git-before-commit-sha \u0026#34;b060762ef93bbe2d03e108d1788eb3505df519a3\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; "}),a.add({id:11,href:'/topics/provider/paths/',title:"Paths",content:"Given 2 manifest file system paths, plans what needs to be applied against a cluster, and what needs to be deleted.\nThis one is the most generic one and can be used when you want to manage almost everything, e.g previous Kahoy execution, prepare using bash scripts, kustomize, secrets\u0026hellip;\nExample of usage:\nkahoy apply \\  --provider \u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;./old-manifests\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; You can use stdin as the new manifests path with - (-n-/--fs-new-manifests-path -).  "}),a.add({id:12,href:'/topics/sync-types/',title:"Sync types",content:"Kahoy can sync Kubernetes resources in two different ways, we will call then partial and full. Using both will leverage the full power of kahoy and make the sync more reliable.\nPartial A partial sync will sync only the resources that have changes.\nKahoy will compare old and new state resources, get the resources that changed (modifications and deletions) and filter the rest.\nThis makes the perfect way of sync on pull requests and similar scenarios because:\n Maintains the scope of the changes on the branch/PR. Reduces the collisions of changes between changes of different people made in parallel.  You can enable this filtering option with --include-changes in any mode.\nExample:\nkahoy apply \\  --dry-run \\  --include-changes \\  --kube-provider-id ci \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Full A full sync is the opposite of partial sync, it will apply all the resources, having changes or not.\nIt will apply all existing resources and delete the missing ones.\nNormally used to sanitize possible external changes. Making the perfect sync to be used at regular intervals (e.g. using in a scheduled pipeline every hour).\nExample:\nkahoy apply \\  --dry-run \\  --kube-provider-id ci \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; "}),a.add({id:13,href:'/topics/batch-priorities/',title:"Batch and priorities",content:"As we have seen in the concepts section, Kahoy has the concept of groups. Kahoy can use these to give special options to all the resources in group.\nPriority If priority is configured for a group, depending on the priority it will be batched and applied differently to the default one.\nThe priority is given with an integer that represents the order of the batches, by default is 1000. This means that a group with a priority of 200, will be batched and applied after a group with priority of 50 and before the default batch 1000.\nNormally should be fine to use the default one (no usage of priorities), however, you may want to deploy some groups first (e.g CRDs, NS\u0026hellip;).\nThe priorities can be configured in Kahoy\u0026rsquo;s config file, lets see an example:\nversion:v1groups:- id:crdpriority:200- id:nspriority:100- id:system/rolespriority:300- id:apps/app1/dependenciespriority:200With this configuration, Kahoy will create 4 batches to apply them in this order:\n 1st batch (100): ns/ resources. 2nd batch (200): crd/ and apps/app1/dependencies resources. 3rd batch (300): system/roles/ resources. 4th batch (1000): Rest of the resources (default priority).  Priorities are not used on resource deletion  Wait Apart from priorities that specify the execution order, you can wait between batches.\nNormally you would wait for some kind of ready condition, however there are lots of different resource types, each resource having lots of different conditions that can be seen as ready. This is complex.\nKahoy took the simplest approach. Instead of implementing tons of ways to wait for a ready condition, its based on eventual consistency concept and a waiting time.\nLets see an example:\ngroups:- id:crdpriority:200wait:duration:5sThis will make kahoy wait 5s after applying the crd batch (200) before continuing applying the next one.\nIf two groups with the same priority have different wait durations, Kahoy will take the highest wait value  "}),a.add({id:14,href:'/topics/filtering/',title:"Filtering resources",content:"  File system level  Exclude paths or files Include paths or files   Resource level  Changes Kubernetes type Kubernetes labels Kubernetes annotations Kubernetes namespaces     Kahoy can filter resources at many levels, they can be used in combination to adapt to your needs, e.g:\n Ignore encrypted secrets Start introducing Kahoy step by step by adding specific paths Ignore specific resources with controller annotations. \u0026hellip;  Let\u0026rsquo;s see the different levels and ways Kahoy can filter.\nFile system level This way of filtering is based on files and paths on the file system, normally used to filter what --fs-new-manifests-path loads, or if paths provider is used, also --fs-old-manifests-path.\nExclude paths or files Enabled with --fs-exclude.\nIs a regex to exclude the files or paths that match, it can be repeated multiple times.\nExample (Don\u0026rsquo;t apply CRDs path and any file with the name secret):\nkahoy apply \\  --include-changes \\  --kube-provider-id ci \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-exclude \u0026#34;manifests/crd\u0026#34; \\  --fs-exclude \u0026#34;secret\u0026#34; Include paths or files Enabled with --fs-include.\nThe opposite exclude, it will only include the ones that match.\nExample (Only apply grafana/ and prometheus/ ):\nkahoy apply \\  --include-changes \\  --kube-provider-id ci \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-include \u0026#34;manifests/monitoring/grafana\u0026#34; \\  --fs-include \u0026#34;manifests/monitoring/prometheus\u0026#34; If both are used at the same time and both match on any path or file, exclude will have preference.  Resource level Filtering at resource level is very powerful because we have all the information of the resources.\nWhen we filter at resource level, Kahoy needs the resource loaded, this means loading all resources (unlike file system filters), normally not a problem nor a bottleneck.  Changes Enabled with --include-changes.\nIt will check the same resource in an old and a new state and if there aren\u0026rsquo;t changes it will exclude the resource.\nExample:\nkahoy apply \\  --include-changes \\  --kube-provider-id ci \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; For more information check partial sync\nKubernetes type Enabled with --kube-exclude-type.\nIs a regular expression that can be repeated, if the resource Kubernetes type (apiVersion and kind) matches with the type, it will exclude.\nExample:\nkahoy apply \\  --kube-provider-id ci \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --kube-exclude-type \u0026#34;v1/Pod\u0026#34; \\  --kube-exclude-type \u0026#34;rbac.authorization.k8s.io\u0026#34; \\  --kube-exclude-type \u0026#34;networking.k8s.io/v1beta1\u0026#34; \\  --kube-exclude-type \u0026#34;auth.bilrost.slok.dev/v1/IngressAuth\u0026#34; Kubernetes labels Enabled with --kube-include-label.\nUses the same Kubernetes label system, and supports the same selectors.\nFor example, --kube-include-label \u0026quot;app=myapp,component!=database,env\u0026quot; would include only the resources that:\n Have app=myapp Don\u0026rsquo;t have component=database Have env label key and any value.  Example (only deploy production outside US):\nkahoy apply \\  --kube-provider-id ci \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --kube-include-label \u0026#34;env=production,region!=us\u0026#34; Kubernetes annotations Enabled with --kube-include-annotation.\nFollows the same rules as the label filter but for annotations.\nExample (exclude resources marked to be managed by a controller):\nkahoy apply \\  --kube-provider-id ci \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --kube-include-annotation \u0026#34;!auth.bilrost.slok.dev/backend\u0026#34; Kubernetes namespaces Enabled with --include-namespace.\nA regex that can be repeated, if none of them match the resource namespace, it will exclude them.\nExample (Exclude everything except app-a and app-b namespaces):\nkahoy apply \\  --kube-provider-id ci \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --include-namespace \u0026#34;app-a\u0026#34; \\  --include-namespace \u0026#34;app-b\u0026#34; "}),a.add({id:15,href:'/topics/report/',title:"Report",content:"Kahoy can give a report at the end of the execution with the information of the resources that have been deleted and applied.\nThis is very flexible and powerful because it gives the ability to plug new apps after Kahoy execution e.g:\n Push notifications Wait for resources be available: Example. Push metrics. Execute sanity checks \u0026hellip;  This approach follows unix philosophy of having multiple tools, each one doing one thing well and combining them to solve an specific problem (e.g Kahoy | jq | waiter).\nBy default it doesn\u0026rsquo;t give the report, use --report-path (-r) flag, using - for stdout (-r -), or a path to an output file (e.g -r /tmp/kahoy-report.json.\nThe format is in JSON because this way it can be combined with tools like [jq], example:\n{ \u0026#34;version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;01EHXWW5XNQF3V8WF14Z3GCAZT\u0026#34;, \u0026#34;started_at\u0026#34;: \u0026#34;2020-09-11T06:15:38Z\u0026#34;, \u0026#34;ended_at\u0026#34;: \u0026#34;2020-09-11T06:15:54Z\u0026#34;, \u0026#34;applied_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;apps/v1/Deployment/test-kahoy/grafana\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/grafana\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;apps/v1/Deployment\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;apps/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Deployment\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;grafana\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;core/v1/Namespace/default/test-kahoy\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;ns\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;/v1/Namespace\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Namespace\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;test-kahoy\u0026#34; } ], \u0026#34;deleted_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role/test-kahoy/prometheus\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/prometheus\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Role\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;prometheus\u0026#34; } ] } "}),a.add({id:16,href:'/topics/garbage-collection/',title:"Garbage collection",content:"The prerequisites to be able to delete missing resources, is to track the existing resources.\nKahoy has a reliable garbage collection system. To implement this, uses the state concept. If something that on the old state, doesn\u0026rsquo;t exist on the new state, it will be deleted.\nTo know more of how resources are tracked and retrieved from the old and new states, you will need to check the different providers.\nResources that haven\u0026rsquo;t been handled by kahoy (manually, other deployment tools\u0026hellip;) will not be tracked, so will not be garbage collected when missing.  "}),a.add({id:17,href:'/topics/configuration-file/',title:"Configuration file",content:"Most of kahoy options are based on flags (and env vars), however it also has some options that are based in a configuration file. The file options.\nBy default it will look for ./kahoy.yml, yet you can configure using --config-file flag.\nLets see what are the available options based on an example:\n# Version of the configuration format.version:v1# File system configuration.fs:# Exclude regex for file paths (same as `--fs-exclude`, can be used both).exclude:- prometheus/secrets- secret*# Include regex for file paths (same as `--fs-include`, can be used both).include:- apps/# List of groups configuration.groups:# Represented by the group ID- id:crd# Priority of the group (by default is 1000). Applied in asc order.priority:200# Wait options.wait:# The time will wait after being applied (Ts, Tm, Th format).duration:5s- id:nspriority:100wait:duration:10s- id:system/rolespriority:300"}),a.add({id:18,href:'/topics/create-namespace/',title:"Create namespace",content:"When we try dry-run style operations against the apiserver (like apply or diff) on namespaced resources, Kubernetes expets the namespaces of these resource to exist. However, on some of these executions the namespace has not been created yet, making the execution fail with a namespace not found error.\nUsing --create-namespace flag in default or diff modes, Kahoy will ensure the namespace exists before trying to apply these resources.\nWhen used in diff mode, a namespace will be created, so be aware of this side effect.  "}),a.add({id:19,href:'/topics/kubernetes-auth/',title:"Kubernetes auth",content:"By default Kubernetes will use the default context and $HOME/.kube/config kubeconfig.\nYou can override these settings with:\n --kube-config. --kube-context.  Kahoy also will configure the kubeconfig path if KUBECONFIG standard env var is used.  "}),a.add({id:20,href:'/use-cases/',title:"Use cases",content:"  Dry run on pull requests Diff for CI Pull requests Deploying on master branch (when PR merged) using Git provider Schedule a full sync Exclude some manifest files (e.g encrypted secrets) Delete all Deploy all Deploy only some manifests Multiple envs batch by priorities Kustomize and Kahoy   Dry run on pull requests When someone pushes a branch different from master, would be nice to execute Dry run on the changes (partial sync) of that branch.\nHaving our manifest in a git repository in ./manifests and being our default branch master, we do this from a different branch.\nkahoy apply \\  --dry-run \\  --include-changes \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Diff for CI Pull requests Same as above but with --diff instead of --dry-run\nDeploying on master branch (when PR merged) using Git provider Kahoy needs to compare our HEAD against the previous applied state, that\u0026rsquo;s why we need the before-commit. In this example, we use --git-before-commit-sha flag. Normally this variable can be obtained in the executing CI:\nGithub actions uses Github context, example:\nenv:GIT_BEFORE_COMMIT_SHA:${{ github.event.before }}So\u0026hellip; in Kahoy:\nkahoy apply \\  --include-changes \\  --git-before-commit-sha \u0026#34;${GIT_BEFORE_COMMIT_SHA}\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Note: For Gitlab CI, this uses env vars (in CI_COMMIT_BEFORE_SHA).\nSchedule a full sync Check this Github actions example for more info.\nExclude some manifest files (e.g encrypted secrets) If you have some files that you don\u0026rsquo;t want to be managed by kahoy, you can ignore them at file system level using --fs-exclude. Can be repeated.\nE.g: exclude any file with the name secret on it.\nkahoy apply \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-exclude \u0026#34;secret\u0026#34; Delete all Use the fs by using the paths provider. Use the new state as dev/null.\nkahoy apply \\  --provider=\u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-new-manifests-path \u0026#34;/dev/null\u0026#34; Deploy all Use the fs by using the paths provider. Use the old state as dev/null.\nkahoy apply \\  --provider=\u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;/dev/null\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Deploy only some manifests You can use the file filtering option --fs-include, works with any provider (git, paths\u0026hellip;)\nkahoy apply \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-include \u0026#34;./manifests/prometheus\u0026#34; \\  --fs-include \u0026#34;./manifests/grafana\u0026#34; Multiple envs If you have multiple envs on the same repository, you can have them in different manifests root.\nkahoy apply \\  --kube-context \u0026#34;env1\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests/env1\u0026#34; kahoy apply \\  --kube-context \u0026#34;env2\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests/env2\u0026#34; batch by priorities Kahoy knows how to manage priorities between groups. By default it will batch all the manifests with a default priority (1000), but maybe you want to deploy some groups first (e.g CRDs or the NS).\nGiven this kahoy.yml on your repo root (or any other path and use --config-file), with the group options:\nversion:v1groups:- id:crdpriority:200- id:nspriority:100- id:system/rolespriority:300it will make Kahoy apply first the ns group, then crd group, then system/roles group, and finally the rest.\nKustomize and Kahoy Check this Kustomize example.\n"}),a.add({id:21,href:'/tutorials/',title:"Tutorials",content:""}),a.add({id:22,href:'/community/',title:"Community",content:"Learn here about the development process and how you can contribute.\n"}),a.add({id:23,href:'/community/contributing/',title:"Contributing",content:"The contributing information is in Github, check CONTRIBUTING.md file\n"}),a.add({id:24,href:'/community/history/',title:"History of the project",content:"TODO\n"}),a.add({id:25,href:'/faq/',title:"F.A.Q",content:"  Can I deploy anything? What does focused on resource level mean? What about CRDs? Why old and new states? Why file changes don\u0026rsquo;t affect resources? Can I have multiple manifests envs on the same repository? Partial and full syncs? How is Garbage collection handled? Why git? When to use paths provider? When to use Kubernetes provider? Env vars as options Kustomize or helm manifests Encrypted secrets? Non resource YAMLs Ignore a resource Why so many filtering options? I have namespace not found error on regular apply or diff Why don\u0026rsquo;t use kubectl prune to delete resources? Github actions integration Configuration file Report   Can I deploy anything? Yes, Kahoy is focused on resource level, you will not need any app scope, labels to group them, or anything similar. You can deploy from 500 apps to 1 namespace.\nWhat does focused on resource level mean? When we talk about resource level, it means that Kahoy identifies what to deploy/delete based on the Kubernetes resource ID (type + ns + name).\nOther solutions add concepts like release (Helm) or app (Kapp), these use/add special fields like labels to identify them.\nNot depending on these fields gives Kahoy, flexibility to deploy anything, and not depending on anything external to what the user defines in its manifests.\nHowever, if you want to group them by app/release, you can always generate these manifests using helm or kustomize templating and let them add those grouping labels, Kahoy will handle correctly the manifests/resources as they are.\nWhat about CRDs? CRDs are also Kubernetes resources, Kahoy knows how to handle them.\nWhy old and new states? In order to be able to track resource changes (e.g track deletion of resource). We need a way to detect what resources have been created/changed/gone.\nAs we explained in another question, Kahoy doesn\u0026rsquo;t depend on special concepts like release/app/special labels\u0026hellip; so to be able to track this we need to use something else, we use a previous (old) state and a current (new) state of the manifests, we compare them and then we can track what has changed.\nNormally the manifests are already in Git, Git has history, so getting this information from git is enough and integrates perfectly with code review flows and Kahoy.\nWhy file changes don\u0026rsquo;t affect resources? Because Kahoy loads resources and then plans what has changed, e.g:\nYou have a file called app.yaml and has these resources with the IDs:\n A service called app1 on the ns apps: v1/Service/apps/app1 A Deployment called app1 on the ns apps: apps/v1/Deployment/apps/app1 An ingress called app1 on the ns apps: networking.k8s.io/v1beta1/Ingress/apps/app1  Now you split the file in\n deployment.yaml: apps/v1/Deployment/apps/app1 svc.yaml: v1/Service/apps/app1 ingress.yaml: networking.k8s.io/v1beta1/Ingress/apps/app1  For Kahoy internally, are the same.\nCan I have multiple manifests envs on the same repository? Yes, Kahoy takes a root manifest-path, as long as that root is the one for the environment, it should be ok.\nYou can invoke Kahoy N times, one per environment.\nPartial and full syncs? Partial syncs filter the resources that will apply based on the changes from one state to another (checks diffs between kubernetes resources in both states). Use --include-changes for partial syncs.\nFull syncs apply all the resources.\nCheck this Github actions example for more info.\nHow is Garbage collection handled? Kahoy takes manifests in 2 states, an old state, and a new state. It compares both and checks what\u0026rsquo;s missing in the new one comparing the old one. Those are the resources that will be deleted (garbage collected).\nThe deletion is made in a resource manner using Kubectl delete, this is safe because Kahoy selects what wants to delete so, it already knows what is going to be delete on the server.\nOther methods like prune are not safe, and that\u0026rsquo;s why Kahoy doesn\u0026rsquo;t use them.\nWhy git? Git maintains history of the manifests, it tracks the changes, can be reverted, is known by almost everyone\u0026hellip; this makes the manifests lifecycle to be reliable.\nThis gives us the opportunity to track changes on our resources, applying a reliable flow based on code reviews (Pull requests).\nThat\u0026rsquo;s why Kahoy understands git, knows how to get two revisions, and compares the manifests that changed in those revisions, plan them and apply.\nWhen to use paths provider? Kahoy understands git and most of the time you will not need it if you are using a repository. However, if you want to make everything yourself, using paths provider gives you full control. e.g:\n Prepare two manifest paths.  new manifests is the main repository old manifests is a copy of new (cp -r) and checkout to a previous revision.   Use --provider=paths to pass those manifest paths (--fs-old-manifests-path, --fs-new-manifests-path) to the two repo paths in different states. If you want to only apply on changes, use --include-changes.  Check an example script that prepares two manifests paths with the different revisions.\nWhen to use Kubernetes provider? When you want Kahoy manage the latest state for you instead of you managing the latest state (e.g: Using Git history).\nThis will make an easy and reliable way of managing the state.\nEnv vars as options You can use environment vars as options using KAHOY_XXXX_XXXX, cli args have priority. e.g:\n --debug: KAHOY_DEBUG --kube-context: KAHOY_KUBE_CONTEXT --provider: KAHOY_PROVIDER --fs-include: KAHOY_FS_INCLUDE \u0026hellip;  Kustomize or helm manifests You can maintain the generated manifests in git as a previous step to make the PRs, this would make that the final autogenerated manifests are committed and ready in the git history, ready to be used by Kahoy at any time (including CI) and cleaner on the PRs when multiple manifests change.\nCheck this Kustomize example.\nEncrypted secrets? Encrypted secrets can\u0026rsquo;t be understood by Kahoy, there are different solutions:\n Ignore encrypted files and apply them separately.  Invoke Kahoy ignoring them using --fs-exclude. Decrypt the secrets. Apply them using Kahoy with --provider=paths and --fs-include option.   Move to a different solution where git repository doesn\u0026rsquo;t have encrypted secrets (webhooks, controllers\u0026hellip;).  Non resource YAMLs Kahoy will try loading all yamls as resources, if it fails, Kahoy will fail, this can be a problem when you have yamls that are not Kubernetes resources.\nUse --fs-exclude, it works with paths and git providers.\nIgnore a resource You can ignore resources at different levels and using multiple filters.\nAt file level you have --fs-include and --fs-exclude, these exclude or include based on filesystem path regexes.\nAt Kubernetes resource level you have others:\n --kube-exclude-type: Exclude based on Kubernetes type regex (e.g: apps/*/Deployment, v1/Pod\u0026hellip;). --kube-include-label: Kubernetes style selector that will select only the resources that match the label selector (e.g: app=myapp,component!=database,env) --kube-include-annotation: Kubernetes style selector that will select only the resources that match the annotation selector (e.g: app=myapp,component!=database,!non-wanted-key)  Why so many filtering options? There isn\u0026rsquo;t a correct manifest structure, grouping, naming\u0026hellip; These can be, spliting a repo per env, a monorepo for everything, a repo for each app\u0026hellip;\nKahoy tries adapting to most use cases, so, having multiple ways of including/excluding resources/manifests is a good way of adapting to the different users.\nAll these filtering options give users a way of solving lots of use cases, for example splitting CI deployments in many ways, e.g:\n Deploy single env on a monorepo identified by paths (--fs-include envs/prod). Deploy single env on a monorepo on the same path, identified by labels, e.g Kustomize generated files (--kube-include-label env=prod). Split CI steps by env. Split CI steps by nature (Kahoy with everything except secrets -\u0026gt; decrypt secrets -\u0026gt; Kahoy all secrets). Updating a single service (--fs-include apps/app1). Exclude encrypted files (--fs-exclude secret) Exclude an specific app (--fs-exclude apps/app1) Ignore CRDs that have an annotation, becase controller change the information (--kube-include-annotation ...) Integrate Kahoy gradually including manifests (--fs-include monitoring/grafana --fs-include monitoring/prometheus) \u0026hellip;  I have namespace not found error on regular apply or diff When we apply a namespaced resource on a namespace that does not exists, the action will fail with an error like:\nError from server (NotFound): namespaces \u0026#34;some-namespace\u0026#34; not found This happens when you don\u0026rsquo;t apply/create the Namespaces before the namespaced Kubernetes resources. Or when you do a diff kahoy --diff. Kahoy uses server-side diff, so it will try a fake/dry-run apply to get the diff and because there is no namespace, it will fail.\nThis is a tricky known problem, to solve this at this moment is only one option, and is to create the namespace before the server-side apply.\nBy default Kahoy will not create the missing namespaces of applied resources, but with --create-namespace, it will. This will work with regular mode kahoy apply and also diff mode kahoy apply --diff.\nBe aware using it with --diff would create a namespace, this means that the diff would have a write operation on the cluster, the ns creation.\nIs a good practice that if you use --create-namespace, you add to your resources the Namespace manifest, this way in the case you delete anytime the resources along with the namespace, the created namespace will be garbage collected by Kahoy.\nWhy don\u0026rsquo;t use kubectl prune to delete resources? TL;DR: Is unpredictable, then risky.\n Official documentation discourages --prune. Official documentation encourages delete -f. You never know what will be deleted exactly beforehand. Can delete resources that we didn\u0026rsquo;t even know they exists (because the selector matches). Can have a big blast radius when an error is made in the prune execution. Some controllers/operators create resources and set the labels with the ones from the original resource, this would make prune delete the controller object on each apply with prune.  Github actions integration Check this Github actions example for more info.\nConfiguration file Kahoy accepts a configuration file (by default ./kahoy.yml) to set options, at this moment these are the options:\n# Version of the configuration format.version:v1# File system configuration.fs:# Exclude regex for file paths (same as `--fs-exclude`, can be used both).exclude:- prometheus/secrets- secret*# Include regex for file paths (same as `--fs-include`, can be used both).include:- apps/# List of groups configuration.groups:# Represented by the group ID- id:crd# Priority of the group (by default is 1000). Applied in asc order.priority:200# Wait options.wait:# The time will wait after being applied (Ts, Tm, Th format).duration:5s- id:nspriority:100wait:duration:10s- id:system/rolespriority:300Report Kahoy can give a report at the end of the execution with the information of the resources that have been deleted and applied.\nThis is very flexible and powerful because it gives the ability to plug new apps after Kahoy execution e.g:\n Push notifications Wait for resources be available: Example. Push metrics. Execute sanity checks \u0026hellip;  This approach follows unix philosophy of having N tools, each one doing one thing (e.g Kahoy | jq | waiter).\nBy default it doesn\u0026rsquo;t give the report, use --report-path (-r) flag, using - for stdout (-r -), or a path to an output file (e.g -r /tmp/kahoy-report.json.\nThe format is in JSON because this way it can be combined with tools like jq, example:\n{ \u0026#34;version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;01EHXWW5XNQF3V8WF14Z3GCAZT\u0026#34;, \u0026#34;started_at\u0026#34;: \u0026#34;2020-09-11T06:15:38Z\u0026#34;, \u0026#34;ended_at\u0026#34;: \u0026#34;2020-09-11T06:15:54Z\u0026#34;, \u0026#34;applied_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;apps/v1/Deployment/test-kahoy/grafana\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/grafana\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;apps/v1/Deployment\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;apps/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Deployment\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;grafana\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;core/v1/Namespace/default/test-kahoy\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;ns\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;/v1/Namespace\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Namespace\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;test-kahoy\u0026#34; } ], \u0026#34;deleted_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role/test-kahoy/prometheus\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/prometheus\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Role\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;prometheus\u0026#34; } ] } "}),a.add({id:26,href:'/glossary/',title:"Glossary",content:"Here are the explanations of some words and phrases used along the documentation.\n Resource Group Provider State Report Kubernetes provider id (storage id) Mode Multipurpose deploy tool Focused on Kubernetes resource Focused on app (or release, service\u0026hellip;) Safe deletion Ready for gitops   Resource Sometimes also called Object.\nA Kubernetes object or resource uniquely identified by Kahoy using the type, group, namespace and name. E.g:\n apps/v1/Deployment/monitoring/grafana core/v1/Service/monitoring/grafana core/v1/ServiceAccount/monitoring/grafana networking.k8s.io/v1beta1/Ingress/monitoring/grafana  Group A group of resources under the same path on the file system.\nProvider The mechanism used to obtain the groups and resources. E.g:\n Git repository using the file system. Kubernetes secrets using the apiserver. A file system path.  State A Kahoy executed snapshot of the resource\u0026rsquo;s data (yaml specs). A provider is used to obtain it. E.g:\n Git hash. Kubernetes secrets with some specific label. An file system path.  Report The output kahoy creates with the resources applied and deleted at the end of an execution.\nKubernetes provider id (storage id) The id used to identify Kahoy state on Kubernetes, giving the ability to execute multiple kahoy independent executions by using different ids on the same cluster and namespace.\nMode The way Kahoy is executed. E.g:\n Dry run. Diff. Default (regular).  Multipurpose deploy tool Means that Kahoy can deploy Kubernetes resources in multiple scenarios and use cases. E.g:\n Independent app/release (Helm style). As a full repository (Flux style). Multiple envs (single repository, env per path). Raw or simple (Kubectl style) \u0026hellip;  Focused on Kubernetes resource Means that Kahoy focuses on the Kubernetes resource to identify and work with each of them (check if resource changed from previous state, filtering\u0026hellip;).\nSo, this means that it doesn\u0026rsquo;t need extra information or mutate the resource itself to track it.\nNormally this implies that you are free to organize the deployment the way you want:\n Multiple apps/releases at the same time. Single app/release. Bunch of random resources (e.g register the CRDs).  Focused on app (or release, service\u0026hellip;) Means that the deployment (tool) identifies what deploys using the concept or the domain of a release/app/service.\nNormally this implies creating a namespace for the resources, adding extra labels to track it\u0026hellip;, and can\u0026rsquo;t be used with multiple resources of different apps at the same time.\nAn example could be Helm or Kapp.\nSafe deletion Kahoy uses per resource identification and tracks each resource independently. This implies that it deletes explicitly the required resources, this method avoids side effects unlike prune that can have side effects and is dangerous to use it.\nReady for gitops Means that Kahoy has been designed with CI, Git and automation in mind, so, is ready to be used in systems like Github actions or Gitlab CI easily.\nMore information about Gitops concept: here\n"}),a.add({id:27,href:'/categories/',title:"Categories",content:""}),a.add({id:28,href:'/tutorials/multiple-envs-deployment/',title:"Deploying to multiple envs",content:"Check Production ready tutorial. It deploys to multiple envs (production and staging).\n"}),a.add({id:29,href:'/tutorials/using-git-provider-copy/',title:"Git provider",content:"Check Kustomize tutorial. It uses Kahoy Git provider as the storage.\n"}),a.add({id:30,href:'/tutorials/gitops-production-ready-flow/',title:"Gitops production ready flow",content:"Check Production ready tutorial. It deploys using Github actions, based on a git repository.\n"}),a.add({id:31,href:'/tutorials/helm-templating/',title:"Helm templating",content:"Check Production ready tutorial. It Uses Helm as the template engine to render multiple apps based on a single generic app chart.\n"}),a.add({id:32,href:'/introduction/',title:"Introduction",content:"Kahoy is a minimal and flexible tool to deploy your Kubernetes raw manifest resources to a cluster.\nIt\u0026rsquo;s based on GitOps principles, and out of the box Kubernetes resources. It does not need apps/releases/services/or any other Custom Resource Definitions to manage deployments.\nKahoy will adapt to your needs and not the other way around, its been designed and developed to be generic and flexible enough for raw manifests without adding unneeded complexity.\nFeatures  Simple, flexible, and lightweight. Deploys a deletes Kubernetes resources. Deploy anything, a Namespace, Ingress, CRD, domain apps (e.g Deployment+Service)\u0026hellip; Garbage collection resources. Load states from different sources/providers (fs, git, kubernetes\u0026hellip;). Plans at Kubernetes resource level (not file/manifest level, not app/release level) Gitops ready (split commands, understands git repositories, apply only changes, Diff, Dry run\u0026hellip;). Use full syncs or partial syncs based on resource changes/diffs. Deploy priorities. Multiple filtering options (file paths, resource namespace, types\u0026hellip;). Push mode (triggered from CI), not pull (controller). Use Kubectl under the hood (Kubernetes \u0026gt;=v1.18 and server-side apply). Safe deletion of resources (doesn\u0026rsquo;t use prune method to delete K8s resources). Reports of what applies and deletes (useful to combine with other apps, e.g: wait, checks, notifications\u0026hellip;).  "}),a.add({id:33,href:'/',title:"Kahoy documentation",content:" When Kubectl is too simple for your needs and available deployment solutions too complex.\n Maintain Kubernetes resources in sync easily.\nYou probably noticed a big gap between what can be done with kubectl and more advanced tools like Helm and FluxCD. But.. what about all the cases where we just need a bit more than what kubectl can offer?\nKahoy is a minimal and flexible tool to deploy your Kubernetes raw manifest resources to a cluster.\nIt\u0026rsquo;s based on GitOps principles, and out of the box Kubernetes resources. It does not need apps/releases/services/or any other Custom Resource Definitions to manage deployments.\nKahoy will adapt to your needs and not the other way around, its been designed and developed to be generic and flexible enough for raw manifests without adding unneeded complexity.\n"}),a.add({id:34,href:'/tutorials/using-kubernetes-provider/',title:"Kubernetes provider",content:"Check Production ready tutorial. It uses Kahoy kubernetes provider.\n"}),a.add({id:35,href:'/tutorials/kustomize-templating/',title:"Kutomize templating",content:"Check kahoy-kustomize-example.\nIt uses Kahoy to render applications and deploy using Kahoy and git storage.\n"}),a.add({id:36,href:'/tutorials/scaling-20k-apps/',title:"Scaling Kahoy to 20k apps",content:"TODO\n"}),a.add({id:37,href:'/tags/',title:"Tags",content:""}),a.add({id:38,href:'/tutorials/waiting-deployments-finish/',title:"Waiting deployment to be ready",content:"Check Production ready tutorial. It has a last stage after the deployments that will use Kahoy report to wait for the deployed resources to be ready (or deleted).\n"})}()