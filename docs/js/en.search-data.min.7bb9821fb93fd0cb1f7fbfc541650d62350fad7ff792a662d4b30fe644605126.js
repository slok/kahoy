'use strict',function(){const b={};b.doc={id:'id',field:['title','content'],store:['title','href']};const a=FlexSearch.create(b);window.geekdocSearchIndex=a,a.add({id:0,href:'/introduction/features/',title:"Features",content:"TODO\n"}),a.add({id:1,href:'/introduction/getting-started/',title:"Getting started",content:"TODO\n"}),a.add({id:2,href:'/introduction/install/',title:"Installing Kahoy",content:"TODO\n"}),a.add({id:3,href:'/topics/',title:"Topics",content:"TODO\n"}),a.add({id:4,href:'/topics/cocepts/',title:"Concepts",content:"Resource TODO\nGroup TODO\nState (provider) TODO\n"}),a.add({id:5,href:'/topics/how-does-it-work/',title:"How does it work",content:"TODO\n"}),a.add({id:6,href:'/topics/modes/',title:"Execution modes",content:"Dry run TODO\nDiff TODO\nDefault TODO\n"}),a.add({id:7,href:'/topics/provider/',title:"Provider",content:"Kahoy needs two manifest states (old and new) to plan what resources need to exist/gone in the cluster. How these manifests are provided is using the provider\n   Provider Easy Flexible Fast History     Kubernetes ✔ ✔ ✖ ✖   Git ✖ ✖ ✔ ✔   Paths ✖ ✔ ✔ ✖    "}),a.add({id:8,href:'/topics/provider/kubernetes/',title:"Kubernetes provider",content:"Given an storage ID and a namespace, at the end of the execution it will store the executed state (applied and deleted resources).\nThe ID is important because you can have different states for each Kahoy execution flows on the same cluster.\n Note: The state is stored with a Secret per existing resource. Be aware of object count quota\n With this state storage, it will load the old manifest state from Kubernetes and new manifest state from an fs path. This means that unlike other modes, using dry-run with Kubernetes provider needs access to a cluster.\nThis provider gives reliable and easy management, but is slower (Needs to get the state from the cluster) and requires space on the cluster to store the state (however the stored resources are compressed).\nExample of usage:\nkahoy apply \\  --provider \u0026#34;kubernetes\u0026#34; \\  --kube-provider-id \u0026#34;ci\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Check kahoy state If you want to check all the resource states, you can do (Check Secret annotations for more information):\nkubectl -n {STORAGE_NAMESPACE} get secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; Move kahoy state In case you want to move kahoy state to another namespaces you can get the resources and apply them in another namespace.\nkubectl -n {STORAGE_OLD_NS} get secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; -o json | \\  jq \u0026#39;.items[].metadata.namespace = \u0026#34;{STORAGE_NEW_NS}\u0026#34;\u0026#39; | \\  kubectl -n {STORAGE_NEW_NS} apply -f- Delete kahoy state In the strange case that you want to reset Kahoy state, you can do it by removing these secrets and apply again all the manifests to create the latest state again:\nkubectl -n {STORAGE_NAMESPACE} delete secrets -l \u0026#39;kahoy.slok.dev/storage-id={STORAGE_ID}\u0026#39; "}),a.add({id:9,href:'/topics/provider/git/',title:"Git provider",content:"This provider understands git and can read states from a git repository, these 2 states are based on 2 git revisions.\nUsing before-commit will make a plan based on the manifests of HEAD (new state) and the commit provided (old state). Normally used when executed from master/main branch.\nInstead of providing the before-commit, by default will get the base parent of the current branch HEAD (new state) against the default branch (old state), normally master/main). This provider is used when you are executing kahoy from a branch in a pull request.\nExample of usage:\nkahoy apply \\  --provider \u0026#34;git\u0026#34; \\  --git-before-commit-sha \u0026#34;b060762ef93bbe2d03e108d1788eb3505df519a3\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; "}),a.add({id:10,href:'/topics/provider/paths/',title:"Paths provider",content:"Given 2 manifest file system paths, plans what needs to be applied against a cluster, and what needs to be deleted.\nThis one is the most generic one and can be used when you want to manage almost everything, e.g previous Kahoy execution, prepare using bash scripts, kustomize, secrets\u0026hellip;\nExample of usage:\nkahoy apply \\  --provider \u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;./old-manifests\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; "}),a.add({id:11,href:'/topics/sync-types/',title:"Sync types",content:"TODO\nPartial TODO\nFull TODO\n"}),a.add({id:12,href:'/topics/batch-priorities/',title:"Batch and priorities",content:"TODO\n"}),a.add({id:13,href:'/topics/filtering/',title:"Filtering resources",content:"TODO\n"}),a.add({id:14,href:'/topics/report/',title:"Report",content:"TODO\n"}),a.add({id:15,href:'/topics/garbage-collection/',title:"Garbage collection",content:"TODO\n"}),a.add({id:16,href:'/topics/configuration-file/',title:"Configuration file",content:"TODO\n"}),a.add({id:17,href:'/use-cases/',title:"Use cases",content:"  Dry run on pull requests Diff for CI Pull requests Deploying on master branch (when PR merged) Schedule a full sync Exclude some manifest files (e.g encrypted secrets) Delete all Deploy all Deploy only some manifests Multiple envs batch by priorities Kustomize and Kahoy   Dry run on pull requests When someone pushes a branch different from master, would be nice to execute Dry run on the changes (partial sync) of that branch.\nHaving our manifest in a git repository in ./manifests and being our default branch master, we do this from a different branch.\nkahoy apply \\  --dry-run \\  --include-changes \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Diff for CI Pull requests Same as above but with --diff instead of --dry-run\nDeploying on master branch (when PR merged) Kahoy needs to compare our HEAD against the previous applied state, that\u0026rsquo;s why we need the before-commit. In this example, we use --git-before-commit-sha flag. Normally this variable can be obtained in the executing CI:\nGithub actions uses Github context, example:\nenv:GIT_BEFORE_COMMIT_SHA:${{ github.event.before }}So\u0026hellip; in Kahoy:\nkahoy apply \\  --include-changes \\  --git-before-commit-sha \u0026#34;${GIT_BEFORE_COMMIT_SHA}\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Note: For Gitlab CI, this uses env vars (in CI_COMMIT_BEFORE_SHA).\nSchedule a full sync Check this Github actions example for more info.\nExclude some manifest files (e.g encrypted secrets) If you have some files that you don\u0026rsquo;t want to be managed by kahoy, you can ignore them at file system level using --fs-exclude. Can be repeated.\nE.g: exclude any file with the name secret on it.\nkahoy apply \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-exclude \u0026#34;secret\u0026#34; Delete all Instead of using git, use the fs by using the paths provider. Use the new state as dev/null.\nkahoy apply \\  --provider=\u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-new-manifests-path \u0026#34;/dev/null\u0026#34; Deploy all Instead of using git, use the fs by using the paths provider. Use the old state as dev/null.\nkahoy apply \\  --provider=\u0026#34;paths\u0026#34; \\  --fs-old-manifests-path \u0026#34;/dev/null\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; Deploy only some manifests You can use the file filtering option --fs-include, works with any provider (git, paths\u0026hellip;)\nkahoy apply \\  --fs-new-manifests-path \u0026#34;./manifests\u0026#34; \\  --fs-include \u0026#34;./manifests/prometheus\u0026#34; \\  --fs-include \u0026#34;./manifests/grafana\u0026#34; Multiple envs If you have multiple envs on the same repository, you can have them in different manifests root.\nkahoy apply \\  --kube-context \u0026#34;env1\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests/env1\u0026#34; kahoy apply \\  --kube-context \u0026#34;env2\u0026#34; \\  --fs-new-manifests-path \u0026#34;./manifests/env2\u0026#34; batch by priorities Kahoy knows how to manage priorities between groups. By default it will batch all the manifests with a default priority (1000), but maybe you want to deploy some groups first (e.g CRDs or the NS).\nGiven this kahoy.yml on your repo root (or any other path and use --config-file), with the group options:\nversion:v1groups:- id:crdpriority:200- id:nspriority:100- id:system/rolespriority:300it will make Kahoy apply first the ns group, then crd group, then system/roles group, and finally the rest.\nKustomize and Kahoy Check this Kustomize example.\n"}),a.add({id:18,href:'/tutorials/',title:"Tutorials",content:"TODO\n"}),a.add({id:19,href:'/community/',title:"Community",content:"TODO\n"}),a.add({id:20,href:'/community/contributing/',title:"Contributing",content:"TODO\n"}),a.add({id:21,href:'/community/history/',title:"History of the project",content:"TODO\n"}),a.add({id:22,href:'/faq/',title:"F.A.Q",content:"  Can I deploy anything? What does focused on resource level mean? What about CRDs? Why old and new states? Why file changes don\u0026rsquo;t affect resources? Can I have multiple manifests envs on the same repository? Partial and full syncs? How is Garbage collection handled? Why git? When to use paths provider? When to use Kubernetes provider? Env vars as options Kustomize or helm manifests Encrypted secrets? Non resource YAMLs Ignore a resource Why so many filtering options? I have namespace not found error on regular apply or diff Why don\u0026rsquo;t use kubectl prune to delete resources? Github actions integration Configuration file Report   Can I deploy anything? Yes, Kahoy is focused on resource level, you will not need any app scope, labels to group them, or anything similar. You can deploy from 500 apps to 1 namespace.\nWhat does focused on resource level mean? When we talk about resource level, it means that Kahoy identifies what to deploy/delete based on the Kubernetes resource ID (type + ns + name).\nOther solutions add concepts like release (Helm) or app (Kapp), these use/add special fields like labels to identify them.\nNot depending on these fields gives Kahoy, flexibility to deploy anything, and not depending on anything external to what the user defines in its manifests.\nHowever, if you want to group them by app/release, you can always generate these manifests using helm or kustomize templating and let them add those grouping labels, Kahoy will handle correctly the manifests/resources as they are.\nWhat about CRDs? CRDs are also Kubernetes resources, Kahoy knows how to handle them.\nWhy old and new states? In order to be able to track resource changes (e.g track deletion of resource). We need a way to detect what resources have been created/changed/gone.\nAs we explained in another question, Kahoy doesn\u0026rsquo;t depend on special concepts like release/app/special labels\u0026hellip; so to be able to track this we need to use something else, we use a previous (old) state and a current (new) state of the manifests, we compare them and then we can track what has changed.\nNormally the manifests are already in Git, Git has history, so getting this information from git is enough and integrates perfectly with code review flows and Kahoy.\nWhy file changes don\u0026rsquo;t affect resources? Because Kahoy loads resources and then plans what has changed, e.g:\nYou have a file called app.yaml and has these resources with the IDs:\n A service called app1 on the ns apps: v1/Service/apps/app1 A Deployment called app1 on the ns apps: apps/v1/Deployment/apps/app1 An ingress called app1 on the ns apps: networking.k8s.io/v1beta1/Ingress/apps/app1  Now you split the file in\n deployment.yaml: apps/v1/Deployment/apps/app1 svc.yaml: v1/Service/apps/app1 ingress.yaml: networking.k8s.io/v1beta1/Ingress/apps/app1  For Kahoy internally, are the same.\nCan I have multiple manifests envs on the same repository? Yes, Kahoy takes a root manifest-path, as long as that root is the one for the environment, it should be ok.\nYou can invoke Kahoy N times, one per environment.\nPartial and full syncs? Partial syncs filter the resources that will apply based on the changes from one state to another (checks diffs between kubernetes resources in both states). Use --include-changes for partial syncs.\nFull syncs apply all the resources.\nCheck this Github actions example for more info.\nHow is Garbage collection handled? Kahoy takes manifests in 2 states, an old state, and a new state. It compares both and checks what\u0026rsquo;s missing in the new one comparing the old one. Those are the resources that will be deleted (garbage collected).\nThe deletion is made in a resource manner using Kubectl delete, this is safe because Kahoy selects what wants to delete so, it already knows what is going to be delete on the server.\nOther methods like prune are not safe, and that\u0026rsquo;s why Kahoy doesn\u0026rsquo;t use them.\nWhy git? Git maintains history of the manifests, it tracks the changes, can be reverted, is known by almost everyone\u0026hellip; this makes the manifests lifecycle to be reliable.\nThis gives us the opportunity to track changes on our resources, applying a reliable flow based on code reviews (Pull requests).\nThat\u0026rsquo;s why Kahoy understands git, knows how to get two revisions, and compares the manifests that changed in those revisions, plan them and apply.\nWhen to use paths provider? Kahoy understands git and most of the time you will not need it if you are using a repository. However, if you want to make everything yourself, using paths provider gives you full control. e.g:\n Prepare two manifest paths.  new manifests is the main repository old manifests is a copy of new (cp -r) and checkout to a previous revision.   Use --provider=paths to pass those manifest paths (--fs-old-manifests-path, --fs-new-manifests-path) to the two repo paths in different states. If you want to only apply on changes, use --include-changes.  Check an example script that prepares two manifests paths with the different revisions.\nWhen to use Kubernetes provider? When you want Kahoy manage the latest state for you instead of you managing the latest state (e.g: Using Git history).\nThis will make an easy and reliable way of managing the state.\nEnv vars as options You can use environment vars as options using KAHOY_XXXX_XXXX, cli args have priority. e.g:\n --debug: KAHOY_DEBUG --kube-context: KAHOY_KUBE_CONTEXT --provider: KAHOY_PROVIDER --fs-include: KAHOY_FS_INCLUDE \u0026hellip;  Kustomize or helm manifests You can maintain the generated manifests in git as a previous step to make the PRs, this would make that the final autogenerated manifests are committed and ready in the git history, ready to be used by Kahoy at any time (including CI) and cleaner on the PRs when multiple manifests change.\nCheck this Kustomize example.\nEncrypted secrets? Encrypted secrets can\u0026rsquo;t be understood by Kahoy, there are different solutions:\n Ignore encrypted files and apply them separately.  Invoke Kahoy ignoring them using --fs-exclude. Decrypt the secrets. Apply them using Kahoy with --provider=paths and --fs-include option.   Move to a different solution where git repository doesn\u0026rsquo;t have encrypted secrets (webhooks, controllers\u0026hellip;).  Non resource YAMLs Kahoy will try loading all yamls as resources, if it fails, Kahoy will fail, this can be a problem when you have yamls that are not Kubernetes resources.\nUse --fs-exclude, it works with paths and git providers.\nIgnore a resource You can ignore resources at different levels and using multiple filters.\nAt file level you have --fs-include and --fs-exclude, these exclude or include based on filesystem path regexes.\nAt Kubernetes resource level you have others:\n --kube-exclude-type: Exclude based on Kubernetes type regex (e.g: apps/*/Deployment, v1/Pod\u0026hellip;). --kube-include-label: Kubernetes style selector that will select only the resources that match the label selector (e.g: app=myapp,component!=database,env) --kube-include-annotation: Kubernetes style selector that will select only the resources that match the annotation selector (e.g: app=myapp,component!=database,!non-wanted-key)  Why so many filtering options? There isn\u0026rsquo;t a correct manifest structure, grouping, naming\u0026hellip; These can be, spliting a repo per env, a monorepo for everything, a repo for each app\u0026hellip;\nKahoy tries adapting to most use cases, so, having multiple ways of including/excluding resources/manifests is a good way of adapting to the different users.\nAll these filtering options give users a way of solving lots of use cases, for example splitting CI deployments in many ways, e.g:\n Deploy single env on a monorepo identified by paths (--fs-include envs/prod). Deploy single env on a monorepo on the same path, identified by labels, e.g Kustomize generated files (--kube-include-label env=prod). Split CI steps by env. Split CI steps by nature (Kahoy with everything except secrets -\u0026gt; decrypt secrets -\u0026gt; Kahoy all secrets). Updating a single service (--fs-include apps/app1). Exclude encrypted files (--fs-exclude secret) Exclude an specific app (--fs-exclude apps/app1) Ignore CRDs that have an annotation, becase controller change the information (--kube-include-annotation ...) Integrate Kahoy gradually including manifests (--fs-include monitoring/grafana --fs-include monitoring/prometheus) \u0026hellip;  I have namespace not found error on regular apply or diff When we apply a namespaced resource on a namespace that does not exists, the action will fail with an error like:\nError from server (NotFound): namespaces \u0026#34;some-namespace\u0026#34; not found This happens when you don\u0026rsquo;t apply/create the Namespaces before the namespaced Kubernetes resources. Or when you do a diff kahoy --diff. Kahoy uses server-side diff, so it will try a fake/dry-run apply to get the diff and because there is no namespace, it will fail.\nThis is a tricky known problem, to solve this at this moment is only one option, and is to create the namespace before the server-side apply.\nBy default Kahoy will not create the missing namespaces of applied resources, but with --create-namespace, it will. This will work with regular mode kahoy apply and also diff mode kahoy apply --diff.\nBe aware using it with --diff would create a namespace, this means that the diff would have a write operation on the cluster, the ns creation.\nIs a good practice that if you use --create-namespace, you add to your resources the Namespace manifest, this way in the case you delete anytime the resources along with the namespace, the created namespace will be garbage collected by Kahoy.\nWhy don\u0026rsquo;t use kubectl prune to delete resources? TL;DR: Is unpredictable, then risky.\n Official documentation discourages --prune. Official documentation encourages delete -f. You never know what will be deleted exactly beforehand. Can delete resources that we didn\u0026rsquo;t even know they exists (because the selector matches). Can have a big blast radius when an error is made in the prune execution. Some controllers/operators create resources and set the labels with the ones from the original resource, this would make prune delete the controller object on each apply with prune.  Github actions integration Check this Github actions example for more info.\nConfiguration file Kahoy accepts a configuration file (by default ./kahoy.yml) to set options, at this moment these are the options:\n# Version of the configuration format.version:v1# File system configuration.fs:# Exclude regex for file paths (same as `--fs-exclude`, can be used both).exclude:- prometheus/secrets- secret*# Include regex for file paths (same as `--fs-include`, can be used both).include:- apps/# List of groups configuration.groups:# Represented by the group ID- id:crd# Priority of the group (by default is 1000). Applied in asc order.priority:200# Wait options.wait:# The time will wait after being applied (Ts, Tm, Th format).duration:5s- id:nspriority:100wait:duration:10s- id:system/rolespriority:300Report Kahoy can give a report at the end of the execution with the information of the resources that have been deleted and applied.\nThis is very flexible and powerful because it gives the ability to plug new apps after Kahoy execution e.g:\n Push notifications Wait for resources be available: Example. Push metrics. Execute sanity checks \u0026hellip;  This approach follows unix philosophy of having N tools, each one doing one thing (e.g Kahoy | jq | waiter).\nBy default it doesn\u0026rsquo;t give the report, use --report-path (-r) flag, using - for stdout (-r -), or a path to an output file (e.g -r /tmp/kahoy-report.json.\nThe format is in JSON because this way it can be combined with tools like jq, example:\n{ \u0026#34;version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;01EHXWW5XNQF3V8WF14Z3GCAZT\u0026#34;, \u0026#34;started_at\u0026#34;: \u0026#34;2020-09-11T06:15:38Z\u0026#34;, \u0026#34;ended_at\u0026#34;: \u0026#34;2020-09-11T06:15:54Z\u0026#34;, \u0026#34;applied_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;apps/v1/Deployment/test-kahoy/grafana\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/grafana\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;apps/v1/Deployment\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;apps/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Deployment\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;grafana\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;core/v1/Namespace/default/test-kahoy\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;ns\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;/v1/Namespace\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Namespace\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;test-kahoy\u0026#34; } ], \u0026#34;deleted_resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role/test-kahoy/prometheus\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;monitoring/prometheus\u0026#34;, \u0026#34;gvk\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1/Role\u0026#34;, \u0026#34;api_version\u0026#34;: \u0026#34;rbac.authorization.k8s.io/v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;Role\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;test-kahoy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;prometheus\u0026#34; } ] } "}),a.add({id:23,href:'/glossary/',title:"Glossary",content:"TODO\n"}),a.add({id:24,href:'/categories/',title:"Categories",content:""}),a.add({id:25,href:'/tutorials/generic-apps-deployments/',title:"Generic app based deployments",content:"TODO\n"}),a.add({id:26,href:'/tutorials/gitops-production-ready-flow/',title:"Gitops production ready flow",content:"TODO\n"}),a.add({id:27,href:'/introduction/',title:"Introduction",content:"TODO Introduction.\nFeatures  Simple, flexible, and lightweight. Deploys a deletes Kubernetes resources. Deploy anything, a Namespace, Ingress, CRD, domain apps (e.g Deployment+Service)\u0026hellip; Garbage collection resources. Load states from different sources/providers (fs, git, kubernetes\u0026hellip;). Plans at Kubernetes resource level (not file/manifest level, not app/release level) Gitops ready (split commands, understands git repositories, apply only changes, Diff, Dry run\u0026hellip;). Use full syncs or partial syncs based on resource changes/diffs. Deploy priorities. Multiple filtering options (file paths, resource namespace, types\u0026hellip;). Push mode (triggered from CI), not pull (controller). Use Kubectl under the hood (Kubernetes \u0026gt;=v1.18 and server-side apply). Safe deletion of resources (doesn\u0026rsquo;t use prune method to delete K8s resources). Reports of what applies and deletes (useful to combine with other apps, e.g: wait, checks, notifications\u0026hellip;).  Alternatives Kahoy born because available alternatives are too complex, Kubernetes is a complex system by itself, adding more complexity in the cases where is not needed, is not a good solution.\n Helm: Tries solving other kinds of problems, has templating (v2 tiller), the concept of releases, used to deploy single apps\u0026hellip; However, you can use helm for templating and kahoy to deploy the generated manifests. Kustomize: Similar scope as helm but with a different approach, like Helm, you can use kustomize for the templating and kahoy for deploying raw manifests. Kapp: As Kahoy, tries solving the same problems of complexity that come with Helm, Kustomize\u0026hellip; Very similar to Kahoy but with more complex options/flows, Kapp focuses on application level, Kahoy on Kubernetes resources, if you need something more complex than Kahoy, is likely that Kapp is your app. Flux: Controller-based flow, very powerful but complex. If you want a more pull than push approach, maybe you want this. Kubectl: Official tool. Is what kahoy uses under the hood, very powerful tool, lots of options, although to make it work correctly with a group of manifests/repository\u0026hellip; you will need scripting or something like Kahoy. We could say that Kahoy is a small layer on top of Kubectl.  Scope  This tool does not perform any form of templating, the generation, and mutation of the YAMLs are out of the scope (We believe the are powerful tools that can be used together with Kahoy for that matter e.g kustomize+kahoy). Manage the lifecycle of Kubernetes resources using raw YAML files and GitOps. Run on CI (dry run, diff, apply) Simplicity and flexibility. Just a bit smarter than Kubectl. Plan what should change declaring current and previous states (read about this in the Concepts section)  If you need complex flows for your Kubernetes resources is likely that Kahoy is not for you.\n"}),a.add({id:28,href:'/',title:"Kahoy documentation",content:" When Kubectl is too simple for your needs and available deployment solutions too complex.\n Maintain Kubernetes resources in sync easily.\nYou probably noticed a big gap between what can be done with kubectl and more advanced tools like Helm and FluxCD. But.. what about all the cases where we just need a bit more than what kubectl can offer?\nKahoy is a minimal and flexible tool to deploy your Kubernetes raw manifest resources to a cluster.\nIt\u0026rsquo;s based on GitOps principles, and out of the box Kubernetes resources. It does not need apps/releases/services/or any other Custom Resource Definitions to manage deployments.\nKahoy will adapt to your needs and not the other way around, its been designed and developed to be generic and flexible enough for raw manifests without adding unneeded complexity.\n"}),a.add({id:29,href:'/tutorials/multicluster-deployments/',title:"Multiple env deployments",content:"TODO\n"}),a.add({id:30,href:'/tutorials/scaling-20k-apps/',title:"Scaling Kahoy to 20k apps",content:"TODO\n"}),a.add({id:31,href:'/tags/',title:"Tags",content:""}),a.add({id:32,href:'/tutorials/using-git-provider/',title:"Using Git provider",content:"TODO\n"}),a.add({id:33,href:'/tutorials/waiting-deployments-finish/',title:"Waiting deployment to be ready",content:"TODO\n"})}()